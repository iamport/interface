// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `v1/payment/payment.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct Payment {
    // message fields
    pub amount: i32,
    pub apply_num: ::std::string::String,
    pub bank_code: i32,
    pub bank_name: ::std::string::String,
    pub buyer_addr: ::std::string::String,
    pub buyer_email: ::std::string::String,
    pub buyer_name: ::std::string::String,
    pub buyer_postcode: ::std::string::String,
    pub buyer_tel: ::std::string::String,
    pub cancel_amount: i32,
    pub cancel_history: ::std::vec::Vec<CancelHistory>,
    pub cancel_reason: ::std::string::String,
    pub cancel_receipt_urls: ::std::vec::Vec<::std::string::String>,
    pub cancelled_at: i32,
    pub card_code: ::std::string::String,
    pub card_name: ::std::string::String,
    pub card_number: ::std::string::String,
    pub card_quota: i32,
    pub card_type: i32,
    pub cash_receipt_issued: bool,
    pub channel: ::std::string::String,
    pub currency: ::std::string::String,
    pub custom_data: ::std::string::String,
    pub customer_uid: ::std::string::String,
    pub customer_uid_usage: ::std::string::String,
    pub escrow: bool,
    pub fail_reason: ::std::string::String,
    pub failed_at: i32,
    pub imp_uid: ::std::string::String,
    pub merchant_uid: ::std::string::String,
    pub name: ::std::string::String,
    pub paid_at: i32,
    pub pay_method: ::std::string::String,
    pub pg_id: ::std::string::String,
    pub pg_provider: ::std::string::String,
    pub pg_tid: ::std::string::String,
    pub receipt_url: ::std::string::String,
    pub started_at: i32,
    pub status: ::std::string::String,
    pub user_agent: ::std::string::String,
    pub vbank_code: ::std::string::String,
    pub vbank_date: i32,
    pub vbank_holder: ::std::string::String,
    pub vbank_issued_at: i32,
    pub vbank_name: ::std::string::String,
    pub vbank_num: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payment {
    fn default() -> &'a Payment {
        <Payment as ::protobuf::Message>::default_instance()
    }
}

impl Payment {
    pub fn new() -> Payment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &Payment| { &m.amount },
            |m: &mut Payment| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "apply_num",
            |m: &Payment| { &m.apply_num },
            |m: &mut Payment| { &mut m.apply_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bank_code",
            |m: &Payment| { &m.bank_code },
            |m: &mut Payment| { &mut m.bank_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bank_name",
            |m: &Payment| { &m.bank_name },
            |m: &mut Payment| { &mut m.bank_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buyer_addr",
            |m: &Payment| { &m.buyer_addr },
            |m: &mut Payment| { &mut m.buyer_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buyer_email",
            |m: &Payment| { &m.buyer_email },
            |m: &mut Payment| { &mut m.buyer_email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buyer_name",
            |m: &Payment| { &m.buyer_name },
            |m: &mut Payment| { &mut m.buyer_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buyer_postcode",
            |m: &Payment| { &m.buyer_postcode },
            |m: &mut Payment| { &mut m.buyer_postcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buyer_tel",
            |m: &Payment| { &m.buyer_tel },
            |m: &mut Payment| { &mut m.buyer_tel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cancel_amount",
            |m: &Payment| { &m.cancel_amount },
            |m: &mut Payment| { &mut m.cancel_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cancel_history",
            |m: &Payment| { &m.cancel_history },
            |m: &mut Payment| { &mut m.cancel_history },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cancel_reason",
            |m: &Payment| { &m.cancel_reason },
            |m: &mut Payment| { &mut m.cancel_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cancel_receipt_urls",
            |m: &Payment| { &m.cancel_receipt_urls },
            |m: &mut Payment| { &mut m.cancel_receipt_urls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cancelled_at",
            |m: &Payment| { &m.cancelled_at },
            |m: &mut Payment| { &mut m.cancelled_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "card_code",
            |m: &Payment| { &m.card_code },
            |m: &mut Payment| { &mut m.card_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "card_name",
            |m: &Payment| { &m.card_name },
            |m: &mut Payment| { &mut m.card_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "card_number",
            |m: &Payment| { &m.card_number },
            |m: &mut Payment| { &mut m.card_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "card_quota",
            |m: &Payment| { &m.card_quota },
            |m: &mut Payment| { &mut m.card_quota },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "card_type",
            |m: &Payment| { &m.card_type },
            |m: &mut Payment| { &mut m.card_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cash_receipt_issued",
            |m: &Payment| { &m.cash_receipt_issued },
            |m: &mut Payment| { &mut m.cash_receipt_issued },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel",
            |m: &Payment| { &m.channel },
            |m: &mut Payment| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency",
            |m: &Payment| { &m.currency },
            |m: &mut Payment| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_data",
            |m: &Payment| { &m.custom_data },
            |m: &mut Payment| { &mut m.custom_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "customer_uid",
            |m: &Payment| { &m.customer_uid },
            |m: &mut Payment| { &mut m.customer_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "customer_uid_usage",
            |m: &Payment| { &m.customer_uid_usage },
            |m: &mut Payment| { &mut m.customer_uid_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "escrow",
            |m: &Payment| { &m.escrow },
            |m: &mut Payment| { &mut m.escrow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fail_reason",
            |m: &Payment| { &m.fail_reason },
            |m: &mut Payment| { &mut m.fail_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failed_at",
            |m: &Payment| { &m.failed_at },
            |m: &mut Payment| { &mut m.failed_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "imp_uid",
            |m: &Payment| { &m.imp_uid },
            |m: &mut Payment| { &mut m.imp_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merchant_uid",
            |m: &Payment| { &m.merchant_uid },
            |m: &mut Payment| { &mut m.merchant_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Payment| { &m.name },
            |m: &mut Payment| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "paid_at",
            |m: &Payment| { &m.paid_at },
            |m: &mut Payment| { &mut m.paid_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pay_method",
            |m: &Payment| { &m.pay_method },
            |m: &mut Payment| { &mut m.pay_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_id",
            |m: &Payment| { &m.pg_id },
            |m: &mut Payment| { &mut m.pg_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_provider",
            |m: &Payment| { &m.pg_provider },
            |m: &mut Payment| { &mut m.pg_provider },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_tid",
            |m: &Payment| { &m.pg_tid },
            |m: &mut Payment| { &mut m.pg_tid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receipt_url",
            |m: &Payment| { &m.receipt_url },
            |m: &mut Payment| { &mut m.receipt_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "started_at",
            |m: &Payment| { &m.started_at },
            |m: &mut Payment| { &mut m.started_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &Payment| { &m.status },
            |m: &mut Payment| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_agent",
            |m: &Payment| { &m.user_agent },
            |m: &mut Payment| { &mut m.user_agent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vbank_code",
            |m: &Payment| { &m.vbank_code },
            |m: &mut Payment| { &mut m.vbank_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vbank_date",
            |m: &Payment| { &m.vbank_date },
            |m: &mut Payment| { &mut m.vbank_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vbank_holder",
            |m: &Payment| { &m.vbank_holder },
            |m: &mut Payment| { &mut m.vbank_holder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vbank_issued_at",
            |m: &Payment| { &m.vbank_issued_at },
            |m: &mut Payment| { &mut m.vbank_issued_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vbank_name",
            |m: &Payment| { &m.vbank_name },
            |m: &mut Payment| { &mut m.vbank_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vbank_num",
            |m: &Payment| { &m.vbank_num },
            |m: &mut Payment| { &mut m.vbank_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Payment>(
            "Payment",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for Payment {
    fn is_initialized(&self) -> bool {
        for v in &self.cancel_history {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.amount = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.apply_num = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bank_code = is.read_int32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bank_name = is.read_string()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.buyer_addr = is.read_string()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.buyer_email = is.read_string()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.buyer_name = is.read_string()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.buyer_postcode = is.read_string()?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.buyer_tel = is.read_string()?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cancel_amount = is.read_int32()?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.cancel_history)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cancel_reason = is.read_string()?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cancel_receipt_urls)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cancelled_at = is.read_int32()?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.card_code = is.read_string()?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.card_name = is.read_string()?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.card_number = is.read_string()?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.card_quota = is.read_int32()?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.card_type = is.read_int32()?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cash_receipt_issued = is.read_bool()?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = is.read_string()?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.currency = is.read_string()?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.custom_data = is.read_string()?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.customer_uid = is.read_string()?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.customer_uid_usage = is.read_string()?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.escrow = is.read_bool()?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fail_reason = is.read_string()?;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.failed_at = is.read_int32()?;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.imp_uid = is.read_string()?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.merchant_uid = is.read_string()?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = is.read_string()?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.paid_at = is.read_int32()?;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pay_method = is.read_string()?;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pg_id = is.read_string()?;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pg_provider = is.read_string()?;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pg_tid = is.read_string()?;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.receipt_url = is.read_string()?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.started_at = is.read_int32()?;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.status = is.read_string()?;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.user_agent = is.read_string()?;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vbank_code = is.read_string()?;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vbank_date = is.read_int32()?;
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vbank_holder = is.read_string()?;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vbank_issued_at = is.read_int32()?;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vbank_name = is.read_string()?;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vbank_num = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.apply_num.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.apply_num);
        }
        if self.bank_code != 0 {
            my_size += ::protobuf::rt::value_size(3, self.bank_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.bank_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.bank_name);
        }
        if !self.buyer_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.buyer_addr);
        }
        if !self.buyer_email.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.buyer_email);
        }
        if !self.buyer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.buyer_name);
        }
        if !self.buyer_postcode.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.buyer_postcode);
        }
        if !self.buyer_tel.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.buyer_tel);
        }
        if self.cancel_amount != 0 {
            my_size += ::protobuf::rt::value_size(10, self.cancel_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cancel_history {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.cancel_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.cancel_reason);
        }
        for value in &self.cancel_receipt_urls {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if self.cancelled_at != 0 {
            my_size += ::protobuf::rt::value_size(14, self.cancelled_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.card_code.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.card_code);
        }
        if !self.card_name.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.card_name);
        }
        if !self.card_number.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.card_number);
        }
        if self.card_quota != 0 {
            my_size += ::protobuf::rt::value_size(18, self.card_quota, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.card_type != 0 {
            my_size += ::protobuf::rt::value_size(19, self.card_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cash_receipt_issued != false {
            my_size += 3;
        }
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.channel);
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.currency);
        }
        if !self.custom_data.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.custom_data);
        }
        if !self.customer_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.customer_uid);
        }
        if !self.customer_uid_usage.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.customer_uid_usage);
        }
        if self.escrow != false {
            my_size += 3;
        }
        if !self.fail_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.fail_reason);
        }
        if self.failed_at != 0 {
            my_size += ::protobuf::rt::value_size(28, self.failed_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.imp_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(29, &self.imp_uid);
        }
        if !self.merchant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.merchant_uid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.name);
        }
        if self.paid_at != 0 {
            my_size += ::protobuf::rt::value_size(32, self.paid_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pay_method.is_empty() {
            my_size += ::protobuf::rt::string_size(33, &self.pay_method);
        }
        if !self.pg_id.is_empty() {
            my_size += ::protobuf::rt::string_size(34, &self.pg_id);
        }
        if !self.pg_provider.is_empty() {
            my_size += ::protobuf::rt::string_size(35, &self.pg_provider);
        }
        if !self.pg_tid.is_empty() {
            my_size += ::protobuf::rt::string_size(36, &self.pg_tid);
        }
        if !self.receipt_url.is_empty() {
            my_size += ::protobuf::rt::string_size(37, &self.receipt_url);
        }
        if self.started_at != 0 {
            my_size += ::protobuf::rt::value_size(38, self.started_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(39, &self.status);
        }
        if !self.user_agent.is_empty() {
            my_size += ::protobuf::rt::string_size(40, &self.user_agent);
        }
        if !self.vbank_code.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.vbank_code);
        }
        if self.vbank_date != 0 {
            my_size += ::protobuf::rt::value_size(42, self.vbank_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.vbank_holder.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.vbank_holder);
        }
        if self.vbank_issued_at != 0 {
            my_size += ::protobuf::rt::value_size(44, self.vbank_issued_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.vbank_name.is_empty() {
            my_size += ::protobuf::rt::string_size(45, &self.vbank_name);
        }
        if !self.vbank_num.is_empty() {
            my_size += ::protobuf::rt::string_size(46, &self.vbank_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amount != 0 {
            os.write_int32(1, self.amount)?;
        }
        if !self.apply_num.is_empty() {
            os.write_string(2, &self.apply_num)?;
        }
        if self.bank_code != 0 {
            os.write_int32(3, self.bank_code)?;
        }
        if !self.bank_name.is_empty() {
            os.write_string(4, &self.bank_name)?;
        }
        if !self.buyer_addr.is_empty() {
            os.write_string(5, &self.buyer_addr)?;
        }
        if !self.buyer_email.is_empty() {
            os.write_string(6, &self.buyer_email)?;
        }
        if !self.buyer_name.is_empty() {
            os.write_string(7, &self.buyer_name)?;
        }
        if !self.buyer_postcode.is_empty() {
            os.write_string(8, &self.buyer_postcode)?;
        }
        if !self.buyer_tel.is_empty() {
            os.write_string(9, &self.buyer_tel)?;
        }
        if self.cancel_amount != 0 {
            os.write_int32(10, self.cancel_amount)?;
        }
        for v in &self.cancel_history {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if !self.cancel_reason.is_empty() {
            os.write_string(12, &self.cancel_reason)?;
        }
        for v in &self.cancel_receipt_urls {
            os.write_string(13, &v)?;
        };
        if self.cancelled_at != 0 {
            os.write_int32(14, self.cancelled_at)?;
        }
        if !self.card_code.is_empty() {
            os.write_string(15, &self.card_code)?;
        }
        if !self.card_name.is_empty() {
            os.write_string(16, &self.card_name)?;
        }
        if !self.card_number.is_empty() {
            os.write_string(17, &self.card_number)?;
        }
        if self.card_quota != 0 {
            os.write_int32(18, self.card_quota)?;
        }
        if self.card_type != 0 {
            os.write_int32(19, self.card_type)?;
        }
        if self.cash_receipt_issued != false {
            os.write_bool(20, self.cash_receipt_issued)?;
        }
        if !self.channel.is_empty() {
            os.write_string(21, &self.channel)?;
        }
        if !self.currency.is_empty() {
            os.write_string(22, &self.currency)?;
        }
        if !self.custom_data.is_empty() {
            os.write_string(23, &self.custom_data)?;
        }
        if !self.customer_uid.is_empty() {
            os.write_string(24, &self.customer_uid)?;
        }
        if !self.customer_uid_usage.is_empty() {
            os.write_string(25, &self.customer_uid_usage)?;
        }
        if self.escrow != false {
            os.write_bool(26, self.escrow)?;
        }
        if !self.fail_reason.is_empty() {
            os.write_string(27, &self.fail_reason)?;
        }
        if self.failed_at != 0 {
            os.write_int32(28, self.failed_at)?;
        }
        if !self.imp_uid.is_empty() {
            os.write_string(29, &self.imp_uid)?;
        }
        if !self.merchant_uid.is_empty() {
            os.write_string(30, &self.merchant_uid)?;
        }
        if !self.name.is_empty() {
            os.write_string(31, &self.name)?;
        }
        if self.paid_at != 0 {
            os.write_int32(32, self.paid_at)?;
        }
        if !self.pay_method.is_empty() {
            os.write_string(33, &self.pay_method)?;
        }
        if !self.pg_id.is_empty() {
            os.write_string(34, &self.pg_id)?;
        }
        if !self.pg_provider.is_empty() {
            os.write_string(35, &self.pg_provider)?;
        }
        if !self.pg_tid.is_empty() {
            os.write_string(36, &self.pg_tid)?;
        }
        if !self.receipt_url.is_empty() {
            os.write_string(37, &self.receipt_url)?;
        }
        if self.started_at != 0 {
            os.write_int32(38, self.started_at)?;
        }
        if !self.status.is_empty() {
            os.write_string(39, &self.status)?;
        }
        if !self.user_agent.is_empty() {
            os.write_string(40, &self.user_agent)?;
        }
        if !self.vbank_code.is_empty() {
            os.write_string(41, &self.vbank_code)?;
        }
        if self.vbank_date != 0 {
            os.write_int32(42, self.vbank_date)?;
        }
        if !self.vbank_holder.is_empty() {
            os.write_string(43, &self.vbank_holder)?;
        }
        if self.vbank_issued_at != 0 {
            os.write_int32(44, self.vbank_issued_at)?;
        }
        if !self.vbank_name.is_empty() {
            os.write_string(45, &self.vbank_name)?;
        }
        if !self.vbank_num.is_empty() {
            os.write_string(46, &self.vbank_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Payment {
        Payment::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static Payment {
        static instance: Payment = Payment {
            amount: 0,
            apply_num: ::std::string::String::new(),
            bank_code: 0,
            bank_name: ::std::string::String::new(),
            buyer_addr: ::std::string::String::new(),
            buyer_email: ::std::string::String::new(),
            buyer_name: ::std::string::String::new(),
            buyer_postcode: ::std::string::String::new(),
            buyer_tel: ::std::string::String::new(),
            cancel_amount: 0,
            cancel_history: ::std::vec::Vec::new(),
            cancel_reason: ::std::string::String::new(),
            cancel_receipt_urls: ::std::vec::Vec::new(),
            cancelled_at: 0,
            card_code: ::std::string::String::new(),
            card_name: ::std::string::String::new(),
            card_number: ::std::string::String::new(),
            card_quota: 0,
            card_type: 0,
            cash_receipt_issued: false,
            channel: ::std::string::String::new(),
            currency: ::std::string::String::new(),
            custom_data: ::std::string::String::new(),
            customer_uid: ::std::string::String::new(),
            customer_uid_usage: ::std::string::String::new(),
            escrow: false,
            fail_reason: ::std::string::String::new(),
            failed_at: 0,
            imp_uid: ::std::string::String::new(),
            merchant_uid: ::std::string::String::new(),
            name: ::std::string::String::new(),
            paid_at: 0,
            pay_method: ::std::string::String::new(),
            pg_id: ::std::string::String::new(),
            pg_provider: ::std::string::String::new(),
            pg_tid: ::std::string::String::new(),
            receipt_url: ::std::string::String::new(),
            started_at: 0,
            status: ::std::string::String::new(),
            user_agent: ::std::string::String::new(),
            vbank_code: ::std::string::String::new(),
            vbank_date: 0,
            vbank_holder: ::std::string::String::new(),
            vbank_issued_at: 0,
            vbank_name: ::std::string::String::new(),
            vbank_num: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Payment {
    fn clear(&mut self) {
        self.amount = 0;
        self.apply_num.clear();
        self.bank_code = 0;
        self.bank_name.clear();
        self.buyer_addr.clear();
        self.buyer_email.clear();
        self.buyer_name.clear();
        self.buyer_postcode.clear();
        self.buyer_tel.clear();
        self.cancel_amount = 0;
        self.cancel_history.clear();
        self.cancel_reason.clear();
        self.cancel_receipt_urls.clear();
        self.cancelled_at = 0;
        self.card_code.clear();
        self.card_name.clear();
        self.card_number.clear();
        self.card_quota = 0;
        self.card_type = 0;
        self.cash_receipt_issued = false;
        self.channel.clear();
        self.currency.clear();
        self.custom_data.clear();
        self.customer_uid.clear();
        self.customer_uid_usage.clear();
        self.escrow = false;
        self.fail_reason.clear();
        self.failed_at = 0;
        self.imp_uid.clear();
        self.merchant_uid.clear();
        self.name.clear();
        self.paid_at = 0;
        self.pay_method.clear();
        self.pg_id.clear();
        self.pg_provider.clear();
        self.pg_tid.clear();
        self.receipt_url.clear();
        self.started_at = 0;
        self.status.clear();
        self.user_agent.clear();
        self.vbank_code.clear();
        self.vbank_date = 0;
        self.vbank_holder.clear();
        self.vbank_issued_at = 0;
        self.vbank_name.clear();
        self.vbank_num.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelHistory {
    // message fields
    pub pg_tid: ::std::string::String,
    pub amount: i32,
    pub cancelled_at: i32,
    pub reason: ::std::string::String,
    pub receipt_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelHistory {
    fn default() -> &'a CancelHistory {
        <CancelHistory as ::protobuf::Message>::default_instance()
    }
}

impl CancelHistory {
    pub fn new() -> CancelHistory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_tid",
            |m: &CancelHistory| { &m.pg_tid },
            |m: &mut CancelHistory| { &mut m.pg_tid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &CancelHistory| { &m.amount },
            |m: &mut CancelHistory| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cancelled_at",
            |m: &CancelHistory| { &m.cancelled_at },
            |m: &mut CancelHistory| { &mut m.cancelled_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &CancelHistory| { &m.reason },
            |m: &mut CancelHistory| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receipt_url",
            |m: &CancelHistory| { &m.receipt_url },
            |m: &mut CancelHistory| { &mut m.receipt_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelHistory>(
            "CancelHistory",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for CancelHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pg_tid = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.amount = is.read_int32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cancelled_at = is.read_int32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reason = is.read_string()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.receipt_url = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pg_tid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pg_tid);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cancelled_at != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cancelled_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.reason);
        }
        if !self.receipt_url.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.receipt_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pg_tid.is_empty() {
            os.write_string(1, &self.pg_tid)?;
        }
        if self.amount != 0 {
            os.write_int32(2, self.amount)?;
        }
        if self.cancelled_at != 0 {
            os.write_int32(3, self.cancelled_at)?;
        }
        if !self.reason.is_empty() {
            os.write_string(4, &self.reason)?;
        }
        if !self.receipt_url.is_empty() {
            os.write_string(5, &self.receipt_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> CancelHistory {
        CancelHistory::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static CancelHistory {
        static instance: CancelHistory = CancelHistory {
            pg_tid: ::std::string::String::new(),
            amount: 0,
            cancelled_at: 0,
            reason: ::std::string::String::new(),
            receipt_url: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for CancelHistory {
    fn clear(&mut self) {
        self.pg_tid.clear();
        self.amount = 0;
        self.cancelled_at = 0;
        self.reason.clear();
        self.receipt_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelHistory {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentPage {
    // message fields
    pub total: i32,
    pub previous: i32,
    pub next: i32,
    pub list: ::std::vec::Vec<Payment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentPage {
    fn default() -> &'a PaymentPage {
        <PaymentPage as ::protobuf::Message>::default_instance()
    }
}

impl PaymentPage {
    pub fn new() -> PaymentPage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &PaymentPage| { &m.total },
            |m: &mut PaymentPage| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "previous",
            |m: &PaymentPage| { &m.previous },
            |m: &mut PaymentPage| { &mut m.previous },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next",
            |m: &PaymentPage| { &m.next },
            |m: &mut PaymentPage| { &mut m.next },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "list",
            |m: &PaymentPage| { &m.list },
            |m: &mut PaymentPage| { &mut m.list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentPage>(
            "PaymentPage",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentPage {
    fn is_initialized(&self) -> bool {
        for v in &self.list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.previous = is.read_int32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.next = is.read_int32()?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.previous != 0 {
            my_size += ::protobuf::rt::value_size(2, self.previous, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next != 0 {
            my_size += ::protobuf::rt::value_size(3, self.next, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_int32(1, self.total)?;
        }
        if self.previous != 0 {
            os.write_int32(2, self.previous)?;
        }
        if self.next != 0 {
            os.write_int32(3, self.next)?;
        }
        for v in &self.list {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentPage {
        PaymentPage::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static PaymentPage {
        static instance: PaymentPage = PaymentPage {
            total: 0,
            previous: 0,
            next: 0,
            list: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentPage {
    fn clear(&mut self) {
        self.total = 0;
        self.previous = 0;
        self.next = 0;
        self.list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentPage {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentBalanceDetail {
    // message fields
    pub tax_free: i32,
    pub supply: i32,
    pub vat: i32,
    pub service: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentBalanceDetail {
    fn default() -> &'a PaymentBalanceDetail {
        <PaymentBalanceDetail as ::protobuf::Message>::default_instance()
    }
}

impl PaymentBalanceDetail {
    pub fn new() -> PaymentBalanceDetail {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tax_free",
            |m: &PaymentBalanceDetail| { &m.tax_free },
            |m: &mut PaymentBalanceDetail| { &mut m.tax_free },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supply",
            |m: &PaymentBalanceDetail| { &m.supply },
            |m: &mut PaymentBalanceDetail| { &mut m.supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vat",
            |m: &PaymentBalanceDetail| { &m.vat },
            |m: &mut PaymentBalanceDetail| { &mut m.vat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service",
            |m: &PaymentBalanceDetail| { &m.service },
            |m: &mut PaymentBalanceDetail| { &mut m.service },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentBalanceDetail>(
            "PaymentBalanceDetail",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentBalanceDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tax_free = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.supply = is.read_int32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vat = is.read_int32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.service = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tax_free != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tax_free, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supply != 0 {
            my_size += ::protobuf::rt::value_size(2, self.supply, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.vat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.service != 0 {
            my_size += ::protobuf::rt::value_size(4, self.service, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tax_free != 0 {
            os.write_int32(1, self.tax_free)?;
        }
        if self.supply != 0 {
            os.write_int32(2, self.supply)?;
        }
        if self.vat != 0 {
            os.write_int32(3, self.vat)?;
        }
        if self.service != 0 {
            os.write_int32(4, self.service)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentBalanceDetail {
        PaymentBalanceDetail::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static PaymentBalanceDetail {
        static instance: PaymentBalanceDetail = PaymentBalanceDetail {
            tax_free: 0,
            supply: 0,
            vat: 0,
            service: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentBalanceDetail {
    fn clear(&mut self) {
        self.tax_free = 0;
        self.supply = 0;
        self.vat = 0;
        self.service = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentBalanceDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentBalanceDetail {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentBalance {
    // message fields
    pub amount: i32,
    pub cash_receipt: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub primary: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub secondary: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub discount: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub histories: ::std::vec::Vec<PaymentBalanceHistory>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentBalance {
    fn default() -> &'a PaymentBalance {
        <PaymentBalance as ::protobuf::Message>::default_instance()
    }
}

impl PaymentBalance {
    pub fn new() -> PaymentBalance {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &PaymentBalance| { &m.amount },
            |m: &mut PaymentBalance| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "cash_receipt",
            |m: &PaymentBalance| { &m.cash_receipt },
            |m: &mut PaymentBalance| { &mut m.cash_receipt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "primary",
            |m: &PaymentBalance| { &m.primary },
            |m: &mut PaymentBalance| { &mut m.primary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "secondary",
            |m: &PaymentBalance| { &m.secondary },
            |m: &mut PaymentBalance| { &mut m.secondary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "discount",
            |m: &PaymentBalance| { &m.discount },
            |m: &mut PaymentBalance| { &mut m.discount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "histories",
            |m: &PaymentBalance| { &m.histories },
            |m: &mut PaymentBalance| { &mut m.histories },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentBalance>(
            "PaymentBalance",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentBalance {
    fn is_initialized(&self) -> bool {
        for v in &self.cash_receipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.primary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secondary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discount {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.histories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.amount = is.read_int32()?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.cash_receipt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.primary)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.secondary)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.discount)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.histories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cash_receipt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.primary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.secondary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.discount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.histories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amount != 0 {
            os.write_int32(1, self.amount)?;
        }
        if let Some(v) = self.cash_receipt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.primary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.secondary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.discount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.histories {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentBalance {
        PaymentBalance::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static PaymentBalance {
        static instance: PaymentBalance = PaymentBalance {
            amount: 0,
            cash_receipt: ::protobuf::MessageField::none(),
            primary: ::protobuf::MessageField::none(),
            secondary: ::protobuf::MessageField::none(),
            discount: ::protobuf::MessageField::none(),
            histories: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentBalance {
    fn clear(&mut self) {
        self.amount = 0;
        self.cash_receipt.clear();
        self.primary.clear();
        self.secondary.clear();
        self.discount.clear();
        self.histories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentBalance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentBalance {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentBalanceHistory {
    // message fields
    pub cash_receipt: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub primary: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub secondary: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub discount: ::protobuf::MessageField<PaymentBalanceDetail>,
    pub created: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentBalanceHistory {
    fn default() -> &'a PaymentBalanceHistory {
        <PaymentBalanceHistory as ::protobuf::Message>::default_instance()
    }
}

impl PaymentBalanceHistory {
    pub fn new() -> PaymentBalanceHistory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "cash_receipt",
            |m: &PaymentBalanceHistory| { &m.cash_receipt },
            |m: &mut PaymentBalanceHistory| { &mut m.cash_receipt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "primary",
            |m: &PaymentBalanceHistory| { &m.primary },
            |m: &mut PaymentBalanceHistory| { &mut m.primary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "secondary",
            |m: &PaymentBalanceHistory| { &m.secondary },
            |m: &mut PaymentBalanceHistory| { &mut m.secondary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalanceDetail>(
            "discount",
            |m: &PaymentBalanceHistory| { &m.discount },
            |m: &mut PaymentBalanceHistory| { &mut m.discount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created",
            |m: &PaymentBalanceHistory| { &m.created },
            |m: &mut PaymentBalanceHistory| { &mut m.created },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentBalanceHistory>(
            "PaymentBalanceHistory",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentBalanceHistory {
    fn is_initialized(&self) -> bool {
        for v in &self.cash_receipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.primary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secondary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.cash_receipt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.primary)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.secondary)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.discount)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.created = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cash_receipt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.primary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.secondary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.discount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.created != 0 {
            my_size += ::protobuf::rt::value_size(5, self.created, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cash_receipt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.primary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.secondary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.discount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.created != 0 {
            os.write_int32(5, self.created)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentBalanceHistory {
        PaymentBalanceHistory::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static PaymentBalanceHistory {
        static instance: PaymentBalanceHistory = PaymentBalanceHistory {
            cash_receipt: ::protobuf::MessageField::none(),
            primary: ::protobuf::MessageField::none(),
            secondary: ::protobuf::MessageField::none(),
            discount: ::protobuf::MessageField::none(),
            created: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentBalanceHistory {
    fn clear(&mut self) {
        self.cash_receipt.clear();
        self.primary.clear();
        self.secondary.clear();
        self.discount.clear();
        self.created = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentBalanceHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentBalanceHistory {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentRequest {
    // message fields
    pub imp_uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentRequest {
    fn default() -> &'a PaymentRequest {
        <PaymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentRequest {
    pub fn new() -> PaymentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "imp_uid",
            |m: &PaymentRequest| { &m.imp_uid },
            |m: &mut PaymentRequest| { &mut m.imp_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentRequest>(
            "PaymentRequest",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.imp_uid = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.imp_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.imp_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.imp_uid.is_empty() {
            os.write_string(1, &self.imp_uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentRequest {
        PaymentRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static PaymentRequest {
        static instance: PaymentRequest = PaymentRequest {
            imp_uid: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentRequest {
    fn clear(&mut self) {
        self.imp_uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::protobuf::MessageField<Payment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentResponse {
    fn default() -> &'a PaymentResponse {
        <PaymentResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentResponse {
    pub fn new() -> PaymentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentResponse| { &m.code },
            |m: &mut PaymentResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentResponse| { &m.message },
            |m: &mut PaymentResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payment>(
            "response",
            |m: &PaymentResponse| { &m.response },
            |m: &mut PaymentResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentResponse>(
            "PaymentResponse",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentResponse {
        PaymentResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static PaymentResponse {
        static instance: PaymentResponse = PaymentResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentsRequest {
    // message fields
    pub imp_uid: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentsRequest {
    fn default() -> &'a PaymentsRequest {
        <PaymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentsRequest {
    pub fn new() -> PaymentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imp_uid",
            |m: &PaymentsRequest| { &m.imp_uid },
            |m: &mut PaymentsRequest| { &mut m.imp_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentsRequest>(
            "PaymentsRequest",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.imp_uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.imp_uid {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.imp_uid {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentsRequest {
        PaymentsRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static PaymentsRequest {
        static instance: PaymentsRequest = PaymentsRequest {
            imp_uid: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentsRequest {
    fn clear(&mut self) {
        self.imp_uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentsRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentsResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::std::vec::Vec<Payment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentsResponse {
    fn default() -> &'a PaymentsResponse {
        <PaymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentsResponse {
    pub fn new() -> PaymentsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentsResponse| { &m.code },
            |m: &mut PaymentsResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentsResponse| { &m.message },
            |m: &mut PaymentsResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "response",
            |m: &PaymentsResponse| { &m.response },
            |m: &mut PaymentsResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentsResponse>(
            "PaymentsResponse",
            9,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        for value in &self.response {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        for v in &self.response {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentsResponse {
        PaymentsResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 9)
    }

    fn default_instance() -> &'static PaymentsResponse {
        static instance: PaymentsResponse = PaymentsResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentsResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentsResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentsMerchantUidRequest {
    // message fields
    pub merchant_uid: ::std::string::String,
    pub status: ::std::string::String,
    pub page: i32,
    pub sorting: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentsMerchantUidRequest {
    fn default() -> &'a PaymentsMerchantUidRequest {
        <PaymentsMerchantUidRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentsMerchantUidRequest {
    pub fn new() -> PaymentsMerchantUidRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merchant_uid",
            |m: &PaymentsMerchantUidRequest| { &m.merchant_uid },
            |m: &mut PaymentsMerchantUidRequest| { &mut m.merchant_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &PaymentsMerchantUidRequest| { &m.status },
            |m: &mut PaymentsMerchantUidRequest| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &PaymentsMerchantUidRequest| { &m.page },
            |m: &mut PaymentsMerchantUidRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sorting",
            |m: &PaymentsMerchantUidRequest| { &m.sorting },
            |m: &mut PaymentsMerchantUidRequest| { &mut m.sorting },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentsMerchantUidRequest>(
            "PaymentsMerchantUidRequest",
            10,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentsMerchantUidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.merchant_uid = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.status = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.page = is.read_int32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sorting = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.merchant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.merchant_uid);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.status);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sorting.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sorting);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.merchant_uid.is_empty() {
            os.write_string(1, &self.merchant_uid)?;
        }
        if !self.status.is_empty() {
            os.write_string(2, &self.status)?;
        }
        if self.page != 0 {
            os.write_int32(3, self.page)?;
        }
        if !self.sorting.is_empty() {
            os.write_string(4, &self.sorting)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentsMerchantUidRequest {
        PaymentsMerchantUidRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static PaymentsMerchantUidRequest {
        static instance: PaymentsMerchantUidRequest = PaymentsMerchantUidRequest {
            merchant_uid: ::std::string::String::new(),
            status: ::std::string::String::new(),
            page: 0,
            sorting: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentsMerchantUidRequest {
    fn clear(&mut self) {
        self.merchant_uid.clear();
        self.status.clear();
        self.page = 0;
        self.sorting.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentsMerchantUidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentsMerchantUidRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentsMerchantUidResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::protobuf::MessageField<PaymentPage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentsMerchantUidResponse {
    fn default() -> &'a PaymentsMerchantUidResponse {
        <PaymentsMerchantUidResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentsMerchantUidResponse {
    pub fn new() -> PaymentsMerchantUidResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentsMerchantUidResponse| { &m.code },
            |m: &mut PaymentsMerchantUidResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentsMerchantUidResponse| { &m.message },
            |m: &mut PaymentsMerchantUidResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentPage>(
            "response",
            |m: &PaymentsMerchantUidResponse| { &m.response },
            |m: &mut PaymentsMerchantUidResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentsMerchantUidResponse>(
            "PaymentsMerchantUidResponse",
            11,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentsMerchantUidResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentsMerchantUidResponse {
        PaymentsMerchantUidResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 11)
    }

    fn default_instance() -> &'static PaymentsMerchantUidResponse {
        static instance: PaymentsMerchantUidResponse = PaymentsMerchantUidResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentsMerchantUidResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentsMerchantUidResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentsMerchantUidResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentStatusRequest {
    // message fields
    pub status: ::std::string::String,
    pub page: i32,
    pub limit: i32,
    pub from: i32,
    pub to: i32,
    pub sorting: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentStatusRequest {
    fn default() -> &'a PaymentStatusRequest {
        <PaymentStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentStatusRequest {
    pub fn new() -> PaymentStatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &PaymentStatusRequest| { &m.status },
            |m: &mut PaymentStatusRequest| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &PaymentStatusRequest| { &m.page },
            |m: &mut PaymentStatusRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &PaymentStatusRequest| { &m.limit },
            |m: &mut PaymentStatusRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from",
            |m: &PaymentStatusRequest| { &m.from },
            |m: &mut PaymentStatusRequest| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to",
            |m: &PaymentStatusRequest| { &m.to },
            |m: &mut PaymentStatusRequest| { &mut m.to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sorting",
            |m: &PaymentStatusRequest| { &m.sorting },
            |m: &mut PaymentStatusRequest| { &mut m.sorting },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentStatusRequest>(
            "PaymentStatusRequest",
            12,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.status = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.page = is.read_int32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = is.read_int32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from = is.read_int32()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.to = is.read_int32()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sorting = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.from != 0 {
            my_size += ::protobuf::rt::value_size(4, self.from, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.to != 0 {
            my_size += ::protobuf::rt::value_size(5, self.to, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sorting.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.sorting);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        if self.page != 0 {
            os.write_int32(2, self.page)?;
        }
        if self.limit != 0 {
            os.write_int32(3, self.limit)?;
        }
        if self.from != 0 {
            os.write_int32(4, self.from)?;
        }
        if self.to != 0 {
            os.write_int32(5, self.to)?;
        }
        if !self.sorting.is_empty() {
            os.write_string(6, &self.sorting)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentStatusRequest {
        PaymentStatusRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 12)
    }

    fn default_instance() -> &'static PaymentStatusRequest {
        static instance: PaymentStatusRequest = PaymentStatusRequest {
            status: ::std::string::String::new(),
            page: 0,
            limit: 0,
            from: 0,
            to: 0,
            sorting: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentStatusRequest {
    fn clear(&mut self) {
        self.status.clear();
        self.page = 0;
        self.limit = 0;
        self.from = 0;
        self.to = 0;
        self.sorting.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentStatusRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentStatusResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::protobuf::MessageField<PaymentPage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentStatusResponse {
    fn default() -> &'a PaymentStatusResponse {
        <PaymentStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentStatusResponse {
    pub fn new() -> PaymentStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentStatusResponse| { &m.code },
            |m: &mut PaymentStatusResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentStatusResponse| { &m.message },
            |m: &mut PaymentStatusResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentPage>(
            "response",
            |m: &PaymentStatusResponse| { &m.response },
            |m: &mut PaymentStatusResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentStatusResponse>(
            "PaymentStatusResponse",
            13,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentStatusResponse {
        PaymentStatusResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 13)
    }

    fn default_instance() -> &'static PaymentStatusResponse {
        static instance: PaymentStatusResponse = PaymentStatusResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentStatusResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentStatusResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentMerchantUidRequest {
    // message fields
    pub merchant_uid: ::std::string::String,
    pub status: ::std::string::String,
    pub sorting: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentMerchantUidRequest {
    fn default() -> &'a PaymentMerchantUidRequest {
        <PaymentMerchantUidRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentMerchantUidRequest {
    pub fn new() -> PaymentMerchantUidRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merchant_uid",
            |m: &PaymentMerchantUidRequest| { &m.merchant_uid },
            |m: &mut PaymentMerchantUidRequest| { &mut m.merchant_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &PaymentMerchantUidRequest| { &m.status },
            |m: &mut PaymentMerchantUidRequest| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sorting",
            |m: &PaymentMerchantUidRequest| { &m.sorting },
            |m: &mut PaymentMerchantUidRequest| { &mut m.sorting },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentMerchantUidRequest>(
            "PaymentMerchantUidRequest",
            14,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentMerchantUidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.merchant_uid = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.status = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sorting = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.merchant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.merchant_uid);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.status);
        }
        if !self.sorting.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sorting);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.merchant_uid.is_empty() {
            os.write_string(1, &self.merchant_uid)?;
        }
        if !self.status.is_empty() {
            os.write_string(2, &self.status)?;
        }
        if !self.sorting.is_empty() {
            os.write_string(3, &self.sorting)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentMerchantUidRequest {
        PaymentMerchantUidRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 14)
    }

    fn default_instance() -> &'static PaymentMerchantUidRequest {
        static instance: PaymentMerchantUidRequest = PaymentMerchantUidRequest {
            merchant_uid: ::std::string::String::new(),
            status: ::std::string::String::new(),
            sorting: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentMerchantUidRequest {
    fn clear(&mut self) {
        self.merchant_uid.clear();
        self.status.clear();
        self.sorting.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentMerchantUidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentMerchantUidRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentMerchantUidResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::protobuf::MessageField<Payment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentMerchantUidResponse {
    fn default() -> &'a PaymentMerchantUidResponse {
        <PaymentMerchantUidResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentMerchantUidResponse {
    pub fn new() -> PaymentMerchantUidResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentMerchantUidResponse| { &m.code },
            |m: &mut PaymentMerchantUidResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentMerchantUidResponse| { &m.message },
            |m: &mut PaymentMerchantUidResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payment>(
            "response",
            |m: &PaymentMerchantUidResponse| { &m.response },
            |m: &mut PaymentMerchantUidResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentMerchantUidResponse>(
            "PaymentMerchantUidResponse",
            15,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentMerchantUidResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentMerchantUidResponse {
        PaymentMerchantUidResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 15)
    }

    fn default_instance() -> &'static PaymentMerchantUidResponse {
        static instance: PaymentMerchantUidResponse = PaymentMerchantUidResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentMerchantUidResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentMerchantUidResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentMerchantUidResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentCancelRequest {
    // message fields
    pub imp_uid: ::std::string::String,
    pub merchant_uid: ::std::string::String,
    pub amount: f64,
    pub tax_free: f64,
    pub checksum: f64,
    pub reason: ::std::string::String,
    pub refund_holder: ::std::string::String,
    pub refund_bank: ::std::string::String,
    pub refund_account: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentCancelRequest {
    fn default() -> &'a PaymentCancelRequest {
        <PaymentCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentCancelRequest {
    pub fn new() -> PaymentCancelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "imp_uid",
            |m: &PaymentCancelRequest| { &m.imp_uid },
            |m: &mut PaymentCancelRequest| { &mut m.imp_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merchant_uid",
            |m: &PaymentCancelRequest| { &m.merchant_uid },
            |m: &mut PaymentCancelRequest| { &mut m.merchant_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &PaymentCancelRequest| { &m.amount },
            |m: &mut PaymentCancelRequest| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tax_free",
            |m: &PaymentCancelRequest| { &m.tax_free },
            |m: &mut PaymentCancelRequest| { &mut m.tax_free },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checksum",
            |m: &PaymentCancelRequest| { &m.checksum },
            |m: &mut PaymentCancelRequest| { &mut m.checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &PaymentCancelRequest| { &m.reason },
            |m: &mut PaymentCancelRequest| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refund_holder",
            |m: &PaymentCancelRequest| { &m.refund_holder },
            |m: &mut PaymentCancelRequest| { &mut m.refund_holder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refund_bank",
            |m: &PaymentCancelRequest| { &m.refund_bank },
            |m: &mut PaymentCancelRequest| { &mut m.refund_bank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refund_account",
            |m: &PaymentCancelRequest| { &m.refund_account },
            |m: &mut PaymentCancelRequest| { &mut m.refund_account },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentCancelRequest>(
            "PaymentCancelRequest",
            16,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentCancelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.imp_uid = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.merchant_uid = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.amount = is.read_double()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tax_free = is.read_double()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.checksum = is.read_double()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reason = is.read_string()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.refund_holder = is.read_string()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.refund_bank = is.read_string()?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.refund_account = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.imp_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.imp_uid);
        }
        if !self.merchant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.merchant_uid);
        }
        if self.amount != 0. {
            my_size += 9;
        }
        if self.tax_free != 0. {
            my_size += 9;
        }
        if self.checksum != 0. {
            my_size += 9;
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.reason);
        }
        if !self.refund_holder.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.refund_holder);
        }
        if !self.refund_bank.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.refund_bank);
        }
        if !self.refund_account.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.refund_account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.imp_uid.is_empty() {
            os.write_string(1, &self.imp_uid)?;
        }
        if !self.merchant_uid.is_empty() {
            os.write_string(2, &self.merchant_uid)?;
        }
        if self.amount != 0. {
            os.write_double(3, self.amount)?;
        }
        if self.tax_free != 0. {
            os.write_double(4, self.tax_free)?;
        }
        if self.checksum != 0. {
            os.write_double(5, self.checksum)?;
        }
        if !self.reason.is_empty() {
            os.write_string(6, &self.reason)?;
        }
        if !self.refund_holder.is_empty() {
            os.write_string(7, &self.refund_holder)?;
        }
        if !self.refund_bank.is_empty() {
            os.write_string(8, &self.refund_bank)?;
        }
        if !self.refund_account.is_empty() {
            os.write_string(9, &self.refund_account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentCancelRequest {
        PaymentCancelRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 16)
    }

    fn default_instance() -> &'static PaymentCancelRequest {
        static instance: PaymentCancelRequest = PaymentCancelRequest {
            imp_uid: ::std::string::String::new(),
            merchant_uid: ::std::string::String::new(),
            amount: 0.,
            tax_free: 0.,
            checksum: 0.,
            reason: ::std::string::String::new(),
            refund_holder: ::std::string::String::new(),
            refund_bank: ::std::string::String::new(),
            refund_account: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentCancelRequest {
    fn clear(&mut self) {
        self.imp_uid.clear();
        self.merchant_uid.clear();
        self.amount = 0.;
        self.tax_free = 0.;
        self.checksum = 0.;
        self.reason.clear();
        self.refund_holder.clear();
        self.refund_bank.clear();
        self.refund_account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentCancelRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentCancelResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::protobuf::MessageField<Payment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentCancelResponse {
    fn default() -> &'a PaymentCancelResponse {
        <PaymentCancelResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentCancelResponse {
    pub fn new() -> PaymentCancelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentCancelResponse| { &m.code },
            |m: &mut PaymentCancelResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentCancelResponse| { &m.message },
            |m: &mut PaymentCancelResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payment>(
            "response",
            |m: &PaymentCancelResponse| { &m.response },
            |m: &mut PaymentCancelResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentCancelResponse>(
            "PaymentCancelResponse",
            17,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentCancelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentCancelResponse {
        PaymentCancelResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 17)
    }

    fn default_instance() -> &'static PaymentCancelResponse {
        static instance: PaymentCancelResponse = PaymentCancelResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentCancelResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentCancelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentCancelResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentBalanceRequest {
    // message fields
    pub imp_uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentBalanceRequest {
    fn default() -> &'a PaymentBalanceRequest {
        <PaymentBalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentBalanceRequest {
    pub fn new() -> PaymentBalanceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "imp_uid",
            |m: &PaymentBalanceRequest| { &m.imp_uid },
            |m: &mut PaymentBalanceRequest| { &mut m.imp_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentBalanceRequest>(
            "PaymentBalanceRequest",
            18,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.imp_uid = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.imp_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.imp_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.imp_uid.is_empty() {
            os.write_string(1, &self.imp_uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentBalanceRequest {
        PaymentBalanceRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 18)
    }

    fn default_instance() -> &'static PaymentBalanceRequest {
        static instance: PaymentBalanceRequest = PaymentBalanceRequest {
            imp_uid: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentBalanceRequest {
    fn clear(&mut self) {
        self.imp_uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentBalanceRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentBalanceResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::protobuf::MessageField<PaymentBalance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentBalanceResponse {
    fn default() -> &'a PaymentBalanceResponse {
        <PaymentBalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentBalanceResponse {
    pub fn new() -> PaymentBalanceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentBalanceResponse| { &m.code },
            |m: &mut PaymentBalanceResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentBalanceResponse| { &m.message },
            |m: &mut PaymentBalanceResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBalance>(
            "response",
            |m: &PaymentBalanceResponse| { &m.response },
            |m: &mut PaymentBalanceResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentBalanceResponse>(
            "PaymentBalanceResponse",
            19,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentBalanceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentBalanceResponse {
        PaymentBalanceResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 19)
    }

    fn default_instance() -> &'static PaymentBalanceResponse {
        static instance: PaymentBalanceResponse = PaymentBalanceResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentBalanceResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentBalanceResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Prepare {
    // message fields
    pub merchant_uid: ::std::string::String,
    pub amount: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Prepare {
    fn default() -> &'a Prepare {
        <Prepare as ::protobuf::Message>::default_instance()
    }
}

impl Prepare {
    pub fn new() -> Prepare {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merchant_uid",
            |m: &Prepare| { &m.merchant_uid },
            |m: &mut Prepare| { &mut m.merchant_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &Prepare| { &m.amount },
            |m: &mut Prepare| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Prepare>(
            "Prepare",
            20,
            fields,
        )
    }
}

impl ::protobuf::Message for Prepare {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.merchant_uid = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.amount = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.merchant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.merchant_uid);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.merchant_uid.is_empty() {
            os.write_string(1, &self.merchant_uid)?;
        }
        if self.amount != 0 {
            os.write_int32(2, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Prepare {
        Prepare::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 20)
    }

    fn default_instance() -> &'static Prepare {
        static instance: Prepare = Prepare {
            merchant_uid: ::std::string::String::new(),
            amount: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Prepare {
    fn clear(&mut self) {
        self.merchant_uid.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Prepare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Prepare {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentPrepareRequest {
    // message fields
    pub merchant_uid: ::std::string::String,
    pub amount: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentPrepareRequest {
    fn default() -> &'a PaymentPrepareRequest {
        <PaymentPrepareRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentPrepareRequest {
    pub fn new() -> PaymentPrepareRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merchant_uid",
            |m: &PaymentPrepareRequest| { &m.merchant_uid },
            |m: &mut PaymentPrepareRequest| { &mut m.merchant_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &PaymentPrepareRequest| { &m.amount },
            |m: &mut PaymentPrepareRequest| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentPrepareRequest>(
            "PaymentPrepareRequest",
            21,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentPrepareRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.merchant_uid = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.amount = is.read_double()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.merchant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.merchant_uid);
        }
        if self.amount != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.merchant_uid.is_empty() {
            os.write_string(1, &self.merchant_uid)?;
        }
        if self.amount != 0. {
            os.write_double(2, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentPrepareRequest {
        PaymentPrepareRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 21)
    }

    fn default_instance() -> &'static PaymentPrepareRequest {
        static instance: PaymentPrepareRequest = PaymentPrepareRequest {
            merchant_uid: ::std::string::String::new(),
            amount: 0.,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentPrepareRequest {
    fn clear(&mut self) {
        self.merchant_uid.clear();
        self.amount = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentPrepareRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentPrepareRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentPrepareResponse {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub response: ::protobuf::MessageField<Prepare>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentPrepareResponse {
    fn default() -> &'a PaymentPrepareResponse {
        <PaymentPrepareResponse as ::protobuf::Message>::default_instance()
    }
}

impl PaymentPrepareResponse {
    pub fn new() -> PaymentPrepareResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &PaymentPrepareResponse| { &m.code },
            |m: &mut PaymentPrepareResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PaymentPrepareResponse| { &m.message },
            |m: &mut PaymentPrepareResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Prepare>(
            "response",
            |m: &PaymentPrepareResponse| { &m.response },
            |m: &mut PaymentPrepareResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentPrepareResponse>(
            "PaymentPrepareResponse",
            22,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentPrepareResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentPrepareResponse {
        PaymentPrepareResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 22)
    }

    fn default_instance() -> &'static PaymentPrepareResponse {
        static instance: PaymentPrepareResponse = PaymentPrepareResponse {
            code: 0,
            message: ::std::string::String::new(),
            response: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentPrepareResponse {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentPrepareResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentPrepareResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentGetPrepareRequest {
    // message fields
    pub merchant_uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentGetPrepareRequest {
    fn default() -> &'a PaymentGetPrepareRequest {
        <PaymentGetPrepareRequest as ::protobuf::Message>::default_instance()
    }
}

impl PaymentGetPrepareRequest {
    pub fn new() -> PaymentGetPrepareRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merchant_uid",
            |m: &PaymentGetPrepareRequest| { &m.merchant_uid },
            |m: &mut PaymentGetPrepareRequest| { &mut m.merchant_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentGetPrepareRequest>(
            "PaymentGetPrepareRequest",
            23,
            fields,
        )
    }
}

impl ::protobuf::Message for PaymentGetPrepareRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.merchant_uid = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.merchant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.merchant_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.merchant_uid.is_empty() {
            os.write_string(1, &self.merchant_uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PaymentGetPrepareRequest {
        PaymentGetPrepareRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 23)
    }

    fn default_instance() -> &'static PaymentGetPrepareRequest {
        static instance: PaymentGetPrepareRequest = PaymentGetPrepareRequest {
            merchant_uid: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PaymentGetPrepareRequest {
    fn clear(&mut self) {
        self.merchant_uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentGetPrepareRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentGetPrepareRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18v1/payment/payment.proto\x12\x07payment\x1a\x1cgoogle/api/annotati\
    ons.proto\"\xcd\x0b\n\x07Payment\x12\x16\n\x06amount\x18\x01\x20\x01(\
    \x05R\x06amount\x12\x1b\n\tapply_num\x18\x02\x20\x01(\tR\x08applyNum\x12\
    \x1b\n\tbank_code\x18\x03\x20\x01(\x05R\x08bankCode\x12\x1b\n\tbank_name\
    \x18\x04\x20\x01(\tR\x08bankName\x12\x1d\n\nbuyer_addr\x18\x05\x20\x01(\
    \tR\tbuyerAddr\x12\x1f\n\x0bbuyer_email\x18\x06\x20\x01(\tR\nbuyerEmail\
    \x12\x1d\n\nbuyer_name\x18\x07\x20\x01(\tR\tbuyerName\x12%\n\x0ebuyer_po\
    stcode\x18\x08\x20\x01(\tR\rbuyerPostcode\x12\x1b\n\tbuyer_tel\x18\t\x20\
    \x01(\tR\x08buyerTel\x12#\n\rcancel_amount\x18\n\x20\x01(\x05R\x0ccancel\
    Amount\x12=\n\x0ecancel_history\x18\x0b\x20\x03(\x0b2\x16.payment.Cancel\
    HistoryR\rcancelHistory\x12#\n\rcancel_reason\x18\x0c\x20\x01(\tR\x0ccan\
    celReason\x12.\n\x13cancel_receipt_urls\x18\r\x20\x03(\tR\x11cancelRecei\
    ptUrls\x12!\n\x0ccancelled_at\x18\x0e\x20\x01(\x05R\x0bcancelledAt\x12\
    \x1b\n\tcard_code\x18\x0f\x20\x01(\tR\x08cardCode\x12\x1b\n\tcard_name\
    \x18\x10\x20\x01(\tR\x08cardName\x12\x1f\n\x0bcard_number\x18\x11\x20\
    \x01(\tR\ncardNumber\x12\x1d\n\ncard_quota\x18\x12\x20\x01(\x05R\tcardQu\
    ota\x12\x1b\n\tcard_type\x18\x13\x20\x01(\x05R\x08cardType\x12.\n\x13cas\
    h_receipt_issued\x18\x14\x20\x01(\x08R\x11cashReceiptIssued\x12\x18\n\
    \x07channel\x18\x15\x20\x01(\tR\x07channel\x12\x1a\n\x08currency\x18\x16\
    \x20\x01(\tR\x08currency\x12\x1f\n\x0bcustom_data\x18\x17\x20\x01(\tR\nc\
    ustomData\x12!\n\x0ccustomer_uid\x18\x18\x20\x01(\tR\x0bcustomerUid\x12,\
    \n\x12customer_uid_usage\x18\x19\x20\x01(\tR\x10customerUidUsage\x12\x16\
    \n\x06escrow\x18\x1a\x20\x01(\x08R\x06escrow\x12\x1f\n\x0bfail_reason\
    \x18\x1b\x20\x01(\tR\nfailReason\x12\x1b\n\tfailed_at\x18\x1c\x20\x01(\
    \x05R\x08failedAt\x12\x17\n\x07imp_uid\x18\x1d\x20\x01(\tR\x06impUid\x12\
    !\n\x0cmerchant_uid\x18\x1e\x20\x01(\tR\x0bmerchantUid\x12\x12\n\x04name\
    \x18\x1f\x20\x01(\tR\x04name\x12\x17\n\x07paid_at\x18\x20\x20\x01(\x05R\
    \x06paidAt\x12\x1d\n\npay_method\x18!\x20\x01(\tR\tpayMethod\x12\x13\n\
    \x05pg_id\x18\"\x20\x01(\tR\x04pgId\x12\x1f\n\x0bpg_provider\x18#\x20\
    \x01(\tR\npgProvider\x12\x15\n\x06pg_tid\x18$\x20\x01(\tR\x05pgTid\x12\
    \x1f\n\x0breceipt_url\x18%\x20\x01(\tR\nreceiptUrl\x12\x1d\n\nstarted_at\
    \x18&\x20\x01(\x05R\tstartedAt\x12\x16\n\x06status\x18'\x20\x01(\tR\x06s\
    tatus\x12\x1d\n\nuser_agent\x18(\x20\x01(\tR\tuserAgent\x12\x1d\n\nvbank\
    _code\x18)\x20\x01(\tR\tvbankCode\x12\x1d\n\nvbank_date\x18*\x20\x01(\
    \x05R\tvbankDate\x12!\n\x0cvbank_holder\x18+\x20\x01(\tR\x0bvbankHolder\
    \x12&\n\x0fvbank_issued_at\x18,\x20\x01(\x05R\rvbankIssuedAt\x12\x1d\n\n\
    vbank_name\x18-\x20\x01(\tR\tvbankName\x12\x1b\n\tvbank_num\x18.\x20\x01\
    (\tR\x08vbankNum\"\x9a\x01\n\rCancelHistory\x12\x15\n\x06pg_tid\x18\x01\
    \x20\x01(\tR\x05pgTid\x12\x16\n\x06amount\x18\x02\x20\x01(\x05R\x06amoun\
    t\x12!\n\x0ccancelled_at\x18\x03\x20\x01(\x05R\x0bcancelledAt\x12\x16\n\
    \x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x1f\n\x0breceipt_url\x18\
    \x05\x20\x01(\tR\nreceiptUrl\"y\n\x0bPaymentPage\x12\x14\n\x05total\x18\
    \x01\x20\x01(\x05R\x05total\x12\x1a\n\x08previous\x18\x02\x20\x01(\x05R\
    \x08previous\x12\x12\n\x04next\x18\x03\x20\x01(\x05R\x04next\x12$\n\x04l\
    ist\x18\x04\x20\x03(\x0b2\x10.payment.PaymentR\x04list\"u\n\x14PaymentBa\
    lanceDetail\x12\x19\n\x08tax_free\x18\x01\x20\x01(\x05R\x07taxFree\x12\
    \x16\n\x06supply\x18\x02\x20\x01(\x05R\x06supply\x12\x10\n\x03vat\x18\
    \x03\x20\x01(\x05R\x03vat\x12\x18\n\x07service\x18\x04\x20\x01(\x05R\x07\
    service\"\xd9\x02\n\x0ePaymentBalance\x12\x16\n\x06amount\x18\x01\x20\
    \x01(\x05R\x06amount\x12@\n\x0ccash_receipt\x18\x02\x20\x01(\x0b2\x1d.pa\
    yment.PaymentBalanceDetailR\x0bcashReceipt\x127\n\x07primary\x18\x03\x20\
    \x01(\x0b2\x1d.payment.PaymentBalanceDetailR\x07primary\x12;\n\tsecondar\
    y\x18\x04\x20\x01(\x0b2\x1d.payment.PaymentBalanceDetailR\tsecondary\x12\
    9\n\x08discount\x18\x05\x20\x01(\x0b2\x1d.payment.PaymentBalanceDetailR\
    \x08discount\x12<\n\thistories\x18\x06\x20\x03(\x0b2\x1e.payment.Payment\
    BalanceHistoryR\thistories\"\xa4\x02\n\x15PaymentBalanceHistory\x12@\n\
    \x0ccash_receipt\x18\x01\x20\x01(\x0b2\x1d.payment.PaymentBalanceDetailR\
    \x0bcashReceipt\x127\n\x07primary\x18\x02\x20\x01(\x0b2\x1d.payment.Paym\
    entBalanceDetailR\x07primary\x12;\n\tsecondary\x18\x03\x20\x01(\x0b2\x1d\
    .payment.PaymentBalanceDetailR\tsecondary\x129\n\x08discount\x18\x04\x20\
    \x01(\x0b2\x1d.payment.PaymentBalanceDetailR\x08discount\x12\x18\n\x07cr\
    eated\x18\x05\x20\x01(\x05R\x07created\")\n\x0ePaymentRequest\x12\x17\n\
    \x07imp_uid\x18\x01\x20\x01(\tR\x06impUid\"m\n\x0fPaymentResponse\x12\
    \x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\x12,\n\x08response\x18\x03\x20\x01(\x0b2\x10\
    .payment.PaymentR\x08response\"*\n\x0fPaymentsRequest\x12\x17\n\x07imp_u\
    id\x18\x01\x20\x03(\tR\x06impUid\"n\n\x10PaymentsResponse\x12\x12\n\x04c\
    ode\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\
    \tR\x07message\x12,\n\x08response\x18\x03\x20\x03(\x0b2\x10.payment.Paym\
    entR\x08response\"\x85\x01\n\x1aPaymentsMerchantUidRequest\x12!\n\x0cmer\
    chant_uid\x18\x01\x20\x01(\tR\x0bmerchantUid\x12\x16\n\x06status\x18\x02\
    \x20\x01(\tR\x06status\x12\x12\n\x04page\x18\x03\x20\x01(\x05R\x04page\
    \x12\x18\n\x07sorting\x18\x04\x20\x01(\tR\x07sorting\"}\n\x1bPaymentsMer\
    chantUidResponse\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\
    \n\x07message\x18\x02\x20\x01(\tR\x07message\x120\n\x08response\x18\x03\
    \x20\x01(\x0b2\x14.payment.PaymentPageR\x08response\"\x96\x01\n\x14Payme\
    ntStatusRequest\x12\x16\n\x06status\x18\x01\x20\x01(\tR\x06status\x12\
    \x12\n\x04page\x18\x02\x20\x01(\x05R\x04page\x12\x14\n\x05limit\x18\x03\
    \x20\x01(\x05R\x05limit\x12\x12\n\x04from\x18\x04\x20\x01(\x05R\x04from\
    \x12\x0e\n\x02to\x18\x05\x20\x01(\x05R\x02to\x12\x18\n\x07sorting\x18\
    \x06\x20\x01(\tR\x07sorting\"w\n\x15PaymentStatusResponse\x12\x12\n\x04c\
    ode\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\
    \tR\x07message\x120\n\x08response\x18\x03\x20\x01(\x0b2\x14.payment.Paym\
    entPageR\x08response\"p\n\x19PaymentMerchantUidRequest\x12!\n\x0cmerchan\
    t_uid\x18\x01\x20\x01(\tR\x0bmerchantUid\x12\x16\n\x06status\x18\x02\x20\
    \x01(\tR\x06status\x12\x18\n\x07sorting\x18\x03\x20\x01(\tR\x07sorting\"\
    x\n\x1aPaymentMerchantUidResponse\x12\x12\n\x04code\x18\x01\x20\x01(\x05\
    R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12,\n\x08\
    response\x18\x03\x20\x01(\x0b2\x10.payment.PaymentR\x08response\"\xa6\
    \x02\n\x14PaymentCancelRequest\x12\x17\n\x07imp_uid\x18\x01\x20\x01(\tR\
    \x06impUid\x12!\n\x0cmerchant_uid\x18\x02\x20\x01(\tR\x0bmerchantUid\x12\
    \x16\n\x06amount\x18\x03\x20\x01(\x01R\x06amount\x12\x19\n\x08tax_free\
    \x18\x04\x20\x01(\x01R\x07taxFree\x12\x1a\n\x08checksum\x18\x05\x20\x01(\
    \x01R\x08checksum\x12\x16\n\x06reason\x18\x06\x20\x01(\tR\x06reason\x12#\
    \n\rrefund_holder\x18\x07\x20\x01(\tR\x0crefundHolder\x12\x1f\n\x0brefun\
    d_bank\x18\x08\x20\x01(\tR\nrefundBank\x12%\n\x0erefund_account\x18\t\
    \x20\x01(\tR\rrefundAccount\"s\n\x15PaymentCancelResponse\x12\x12\n\x04c\
    ode\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\
    \tR\x07message\x12,\n\x08response\x18\x03\x20\x01(\x0b2\x10.payment.Paym\
    entR\x08response\"0\n\x15PaymentBalanceRequest\x12\x17\n\x07imp_uid\x18\
    \x01\x20\x01(\tR\x06impUid\"{\n\x16PaymentBalanceResponse\x12\x12\n\x04c\
    ode\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\
    \tR\x07message\x123\n\x08response\x18\x03\x20\x01(\x0b2\x17.payment.Paym\
    entBalanceR\x08response\"D\n\x07Prepare\x12!\n\x0cmerchant_uid\x18\x01\
    \x20\x01(\tR\x0bmerchantUid\x12\x16\n\x06amount\x18\x02\x20\x01(\x05R\
    \x06amount\"R\n\x15PaymentPrepareRequest\x12!\n\x0cmerchant_uid\x18\x01\
    \x20\x01(\tR\x0bmerchantUid\x12\x16\n\x06amount\x18\x02\x20\x01(\x01R\
    \x06amount\"t\n\x16PaymentPrepareResponse\x12\x12\n\x04code\x18\x01\x20\
    \x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\
    \x12,\n\x08response\x18\x03\x20\x01(\x0b2\x10.payment.PrepareR\x08respon\
    se\"=\n\x18PaymentGetPrepareRequest\x12!\n\x0cmerchant_uid\x18\x01\x20\
    \x01(\tR\x0bmerchantUid2\x8e\t\n\x0ePaymentService\x12\x80\x01\n\x11Paym\
    entBalanceRPC\x12\x1e.payment.PaymentBalanceRequest\x1a\x1f.payment.Paym\
    entBalanceResponse\"*\x82\xd3\xe4\x93\x02$\x12\"/api/v1/payments/{imp_ui\
    d}/balance\x12c\n\nPaymentRPC\x12\x17.payment.PaymentRequest\x1a\x18.pay\
    ment.PaymentResponse\"\"\x82\xd3\xe4\x93\x02\x1c\x12\x1a/api/v1/payments\
    /{imp_uid}\x12\\\n\x0bPaymentsRPC\x12\x18.payment.PaymentsRequest\x1a\
    \x19.payment.PaymentsResponse\"\x18\x82\xd3\xe4\x93\x02\x12\x12\x10/api/\
    v1/payments\x12\x97\x01\n\x15PaymentMerchantUidRPC\x12\".payment.Payment\
    MerchantUidRequest\x1a#.payment.PaymentMerchantUidResponse\"5\x82\xd3\
    \xe4\x93\x02/\x12-/api/v1/payments/find/{merchant_uid}/{status}\x12\x9d\
    \x01\n\x16PaymentsMerchantUidRPC\x12#.payment.PaymentsMerchantUidRequest\
    \x1a$.payment.PaymentsMerchantUidResponse\"8\x82\xd3\xe4\x93\x022\x120/a\
    pi/v1/payments/findAll/{merchant_uid}/{status}\x12|\n\x11PaymentsStatusR\
    PC\x12\x1d.payment.PaymentStatusRequest\x1a\x1e.payment.PaymentStatusRes\
    ponse\"(\x82\xd3\xe4\x93\x02\"\x12\x20/api/v1/payments/status/{status}\
    \x12u\n\x10PaymentCanselRPC\x12\x1d.payment.PaymentCancelRequest\x1a\x1e\
    .payment.PaymentCancelResponse\"\"\x82\xd3\xe4\x93\x02\x1c\"\x17/api/v1/\
    payments/cancel:\x01*\x12y\n\x11PaymentPrepareRPC\x12\x1e.payment.Paymen\
    tPrepareRequest\x1a\x1f.payment.PaymentPrepareResponse\"#\x82\xd3\xe4\
    \x93\x02\x1d\"\x18/api/v1/payments/prepare:\x01*\x12\x8b\x01\n\x14Paymen\
    tGetPrepareRPC\x12!.payment.PaymentGetPrepareRequest\x1a\x1f.payment.Pay\
    mentPrepareResponse\"/\x82\xd3\xe4\x93\x02)\x12'/api/v1/payments/prepare\
    /{merchant_uid}B4Z2github.com/iamport/interface/gen_src/go/v1/paymentJ\
    \x8dD\n\x07\x12\x05\0\0\x82\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\
    \x08\n\x01\x02\x12\x03\x01\0\x10\n\t\n\x02\x03\0\x12\x03\x03\0&\n\x08\n\
    \x01\x08\x12\x03\x04\0I\n\t\n\x02\x08\x0b\x12\x03\x04\0I\n\n\n\x02\x06\0\
    \x12\x04\x06\0>\x01\n\n\n\x03\x06\0\x01\x12\x03\x06\x08\x16\n\x0c\n\x04\
    \x06\0\x02\0\x12\x04\x07\x04\x0b\x05\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\
    \x07\x08\x19\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x07\x1a/\n\x0c\n\x05\
    \x06\0\x02\0\x03\x12\x03\x07:P\n\r\n\x05\x06\0\x02\0\x04\x12\x04\x08\x08\
    \n\n\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04\x08\x08\n\n\n\x0c\n\
    \x04\x06\0\x02\x01\x12\x04\r\x04\x11\x05\n\x0c\n\x05\x06\0\x02\x01\x01\
    \x12\x03\r\x08\x12\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\r\x13!\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03\r,;\n\r\n\x05\x06\0\x02\x01\x04\x12\x04\
    \x0e\x08\x10\n\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04\x0e\x08\
    \x10\n\n\x0c\n\x04\x06\0\x02\x02\x12\x04\x13\x04\x17\x05\n\x0c\n\x05\x06\
    \0\x02\x02\x01\x12\x03\x13\x08\x13\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\
    \x13\x14#\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x13.>\n\r\n\x05\x06\0\
    \x02\x02\x04\x12\x04\x14\x08\x16\n\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\
    \xbc\"\x12\x04\x14\x08\x16\n\n\x0c\n\x04\x06\0\x02\x03\x12\x04\x19\x04\
    \x1d\x05\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x19\x08\x1d\n\x0c\n\x05\
    \x06\0\x02\x03\x02\x12\x03\x19\x1e7\n\x0c\n\x05\x06\0\x02\x03\x03\x12\
    \x03\x19B\\\n\r\n\x05\x06\0\x02\x03\x04\x12\x04\x1a\x08\x1c\n\n\x11\n\t\
    \x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04\x1a\x08\x1c\n\n\x0c\n\x04\x06\0\
    \x02\x04\x12\x04\x1f\x04#\x05\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x1f\
    \x08\x1e\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\x1f\x1f9\n\x0c\n\x05\x06\
    \0\x02\x04\x03\x12\x03\x1fD_\n\r\n\x05\x06\0\x02\x04\x04\x12\x04\x20\x08\
    \"\n\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x04\x20\x08\"\n\n\x0c\
    \n\x04\x06\0\x02\x05\x12\x04%\x04)\x05\n\x0c\n\x05\x06\0\x02\x05\x01\x12\
    \x03%\x08\x19\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03%\x1a.\n\x0c\n\x05\
    \x06\0\x02\x05\x03\x12\x03%9N\n\r\n\x05\x06\0\x02\x05\x04\x12\x04&\x08(\
    \n\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x04&\x08(\n\n\x0c\n\x04\
    \x06\0\x02\x06\x12\x04+\x040\x05\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03+\
    \x08\x18\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03+\x19-\n\x0c\n\x05\x06\0\
    \x02\x06\x03\x12\x03+8M\n\r\n\x05\x06\0\x02\x06\x04\x12\x04,\x08/\n\n\
    \x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x04,\x08/\n\n\x0c\n\x04\x06\
    \0\x02\x07\x12\x042\x047\x05\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x032\x08\
    \x19\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x032\x1a/\n\x0c\n\x05\x06\0\x02\
    \x07\x03\x12\x032:P\n\r\n\x05\x06\0\x02\x07\x04\x12\x043\x086\n\n\x11\n\
    \t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x043\x086\n\n\x0c\n\x04\x06\0\x02\
    \x08\x12\x049\x04=\x05\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x039\x08\x1c\n\
    \x0c\n\x05\x06\0\x02\x08\x02\x12\x039\x1d5\n\x0c\n\x05\x06\0\x02\x08\x03\
    \x12\x039@V\n\r\n\x05\x06\0\x02\x08\x04\x12\x04:\x08<\n\n\x11\n\t\x06\0\
    \x02\x08\x04\xb0\xca\xbc\"\x12\x04:\x08<\n\n\n\n\x02\x04\0\x12\x04@\0o\
    \x01\n\n\n\x03\x04\0\x01\x12\x03@\x08\x0f\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03A\x04\x15\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03A\x04\t\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03A\n\x10\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03A\x13\x14\
    \n\x0b\n\x04\x04\0\x02\x01\x12\x03B\x04\x19\n\x0c\n\x05\x04\0\x02\x01\
    \x05\x12\x03B\x04\n\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03B\x0b\x14\n\x0c\
    \n\x05\x04\0\x02\x01\x03\x12\x03B\x17\x18\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03C\x04\x18\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03C\x04\t\n\x0c\n\x05\
    \x04\0\x02\x02\x01\x12\x03C\n\x13\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03C\
    \x16\x17\n\x0b\n\x04\x04\0\x02\x03\x12\x03D\x04\x19\n\x0c\n\x05\x04\0\
    \x02\x03\x05\x12\x03D\x04\n\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03D\x0b\
    \x14\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03D\x17\x18\n\x0b\n\x04\x04\0\
    \x02\x04\x12\x03E\x04\x1a\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03E\x04\n\n\
    \x0c\n\x05\x04\0\x02\x04\x01\x12\x03E\x0b\x15\n\x0c\n\x05\x04\0\x02\x04\
    \x03\x12\x03E\x18\x19\n\x0b\n\x04\x04\0\x02\x05\x12\x03F\x04\x1b\n\x0c\n\
    \x05\x04\0\x02\x05\x05\x12\x03F\x04\n\n\x0c\n\x05\x04\0\x02\x05\x01\x12\
    \x03F\x0b\x16\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03F\x19\x1a\n\x0b\n\x04\
    \x04\0\x02\x06\x12\x03G\x04\x1a\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03G\
    \x04\n\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03G\x0b\x15\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03G\x18\x19\n\x0b\n\x04\x04\0\x02\x07\x12\x03H\x04\x1e\
    \n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03H\x04\n\n\x0c\n\x05\x04\0\x02\x07\
    \x01\x12\x03H\x0b\x19\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03H\x1c\x1d\n\
    \x0b\n\x04\x04\0\x02\x08\x12\x03I\x04\x19\n\x0c\n\x05\x04\0\x02\x08\x05\
    \x12\x03I\x04\n\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03I\x0b\x14\n\x0c\n\
    \x05\x04\0\x02\x08\x03\x12\x03I\x17\x18\n\x0b\n\x04\x04\0\x02\t\x12\x03J\
    \x04\x1d\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03J\x04\t\n\x0c\n\x05\x04\0\
    \x02\t\x01\x12\x03J\n\x17\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03J\x1a\x1c\n\
    \x0b\n\x04\x04\0\x02\n\x12\x03K\x04/\n\x0c\n\x05\x04\0\x02\n\x04\x12\x03\
    K\x04\x0c\n\x0c\n\x05\x04\0\x02\n\x06\x12\x03K\r\x1a\n\x0c\n\x05\x04\0\
    \x02\n\x01\x12\x03K\x1b)\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03K,.\n\x0b\n\
    \x04\x04\0\x02\x0b\x12\x03L\x04\x1e\n\x0c\n\x05\x04\0\x02\x0b\x05\x12\
    \x03L\x04\n\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03L\x0b\x18\n\x0c\n\x05\
    \x04\0\x02\x0b\x03\x12\x03L\x1b\x1d\n\x0b\n\x04\x04\0\x02\x0c\x12\x03M\
    \x04-\n\x0c\n\x05\x04\0\x02\x0c\x04\x12\x03M\x04\x0c\n\x0c\n\x05\x04\0\
    \x02\x0c\x05\x12\x03M\r\x13\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03M\x14'\
    \n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03M*,\n\x0b\n\x04\x04\0\x02\r\x12\
    \x03N\x04\x1c\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03N\x04\t\n\x0c\n\x05\x04\
    \0\x02\r\x01\x12\x03N\n\x16\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03N\x19\x1b\
    \n\x0b\n\x04\x04\0\x02\x0e\x12\x03O\x04\x1a\n\x0c\n\x05\x04\0\x02\x0e\
    \x05\x12\x03O\x04\n\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03O\x0b\x14\n\x0c\
    \n\x05\x04\0\x02\x0e\x03\x12\x03O\x17\x19\n\x0b\n\x04\x04\0\x02\x0f\x12\
    \x03P\x04\x1a\n\x0c\n\x05\x04\0\x02\x0f\x05\x12\x03P\x04\n\n\x0c\n\x05\
    \x04\0\x02\x0f\x01\x12\x03P\x0b\x14\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\
    \x03P\x17\x19\n\x0b\n\x04\x04\0\x02\x10\x12\x03Q\x04\x1c\n\x0c\n\x05\x04\
    \0\x02\x10\x05\x12\x03Q\x04\n\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x03Q\x0b\
    \x16\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x03Q\x19\x1b\n\x0b\n\x04\x04\0\
    \x02\x11\x12\x03R\x04\x1a\n\x0c\n\x05\x04\0\x02\x11\x05\x12\x03R\x04\t\n\
    \x0c\n\x05\x04\0\x02\x11\x01\x12\x03R\n\x14\n\x0c\n\x05\x04\0\x02\x11\
    \x03\x12\x03R\x17\x19\n\x0b\n\x04\x04\0\x02\x12\x12\x03S\x04\x19\n\x0c\n\
    \x05\x04\0\x02\x12\x05\x12\x03S\x04\t\n\x0c\n\x05\x04\0\x02\x12\x01\x12\
    \x03S\n\x13\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x03S\x16\x18\n\x0b\n\x04\
    \x04\0\x02\x13\x12\x03T\x04\"\n\x0c\n\x05\x04\0\x02\x13\x05\x12\x03T\x04\
    \x08\n\x0c\n\x05\x04\0\x02\x13\x01\x12\x03T\t\x1c\n\x0c\n\x05\x04\0\x02\
    \x13\x03\x12\x03T\x1f!\n\x0b\n\x04\x04\0\x02\x14\x12\x03U\x04\x18\n\x0c\
    \n\x05\x04\0\x02\x14\x05\x12\x03U\x04\n\n\x0c\n\x05\x04\0\x02\x14\x01\
    \x12\x03U\x0b\x12\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x03U\x15\x17\n\x0b\n\
    \x04\x04\0\x02\x15\x12\x03V\x04\x19\n\x0c\n\x05\x04\0\x02\x15\x05\x12\
    \x03V\x04\n\n\x0c\n\x05\x04\0\x02\x15\x01\x12\x03V\x0b\x13\n\x0c\n\x05\
    \x04\0\x02\x15\x03\x12\x03V\x16\x18\n\x0b\n\x04\x04\0\x02\x16\x12\x03W\
    \x04\x1c\n\x0c\n\x05\x04\0\x02\x16\x05\x12\x03W\x04\n\n\x0c\n\x05\x04\0\
    \x02\x16\x01\x12\x03W\x0b\x16\n\x0c\n\x05\x04\0\x02\x16\x03\x12\x03W\x19\
    \x1b\n\x0b\n\x04\x04\0\x02\x17\x12\x03X\x04\x1d\n\x0c\n\x05\x04\0\x02\
    \x17\x05\x12\x03X\x04\n\n\x0c\n\x05\x04\0\x02\x17\x01\x12\x03X\x0b\x17\n\
    \x0c\n\x05\x04\0\x02\x17\x03\x12\x03X\x1a\x1c\n\x0b\n\x04\x04\0\x02\x18\
    \x12\x03Y\x04#\n\x0c\n\x05\x04\0\x02\x18\x05\x12\x03Y\x04\n\n\x0c\n\x05\
    \x04\0\x02\x18\x01\x12\x03Y\x0b\x1d\n\x0c\n\x05\x04\0\x02\x18\x03\x12\
    \x03Y\x20\"\n\x0b\n\x04\x04\0\x02\x19\x12\x03Z\x04\x15\n\x0c\n\x05\x04\0\
    \x02\x19\x05\x12\x03Z\x04\x08\n\x0c\n\x05\x04\0\x02\x19\x01\x12\x03Z\t\
    \x0f\n\x0c\n\x05\x04\0\x02\x19\x03\x12\x03Z\x12\x14\n\x0b\n\x04\x04\0\
    \x02\x1a\x12\x03[\x04\x1c\n\x0c\n\x05\x04\0\x02\x1a\x05\x12\x03[\x04\n\n\
    \x0c\n\x05\x04\0\x02\x1a\x01\x12\x03[\x0b\x16\n\x0c\n\x05\x04\0\x02\x1a\
    \x03\x12\x03[\x19\x1b\n\x0b\n\x04\x04\0\x02\x1b\x12\x03\\\x04\x19\n\x0c\
    \n\x05\x04\0\x02\x1b\x05\x12\x03\\\x04\t\n\x0c\n\x05\x04\0\x02\x1b\x01\
    \x12\x03\\\n\x13\n\x0c\n\x05\x04\0\x02\x1b\x03\x12\x03\\\x16\x18\n\x0b\n\
    \x04\x04\0\x02\x1c\x12\x03]\x04\x18\n\x0c\n\x05\x04\0\x02\x1c\x05\x12\
    \x03]\x04\n\n\x0c\n\x05\x04\0\x02\x1c\x01\x12\x03]\x0b\x12\n\x0c\n\x05\
    \x04\0\x02\x1c\x03\x12\x03]\x15\x17\n\x0b\n\x04\x04\0\x02\x1d\x12\x03^\
    \x04\x1d\n\x0c\n\x05\x04\0\x02\x1d\x05\x12\x03^\x04\n\n\x0c\n\x05\x04\0\
    \x02\x1d\x01\x12\x03^\x0b\x17\n\x0c\n\x05\x04\0\x02\x1d\x03\x12\x03^\x1a\
    \x1c\n\x0b\n\x04\x04\0\x02\x1e\x12\x03_\x04\x15\n\x0c\n\x05\x04\0\x02\
    \x1e\x05\x12\x03_\x04\n\n\x0c\n\x05\x04\0\x02\x1e\x01\x12\x03_\x0b\x0f\n\
    \x0c\n\x05\x04\0\x02\x1e\x03\x12\x03_\x12\x14\n\x0b\n\x04\x04\0\x02\x1f\
    \x12\x03`\x04\x17\n\x0c\n\x05\x04\0\x02\x1f\x05\x12\x03`\x04\t\n\x0c\n\
    \x05\x04\0\x02\x1f\x01\x12\x03`\n\x11\n\x0c\n\x05\x04\0\x02\x1f\x03\x12\
    \x03`\x14\x16\n\x0b\n\x04\x04\0\x02\x20\x12\x03a\x04\x1b\n\x0c\n\x05\x04\
    \0\x02\x20\x05\x12\x03a\x04\n\n\x0c\n\x05\x04\0\x02\x20\x01\x12\x03a\x0b\
    \x15\n\x0c\n\x05\x04\0\x02\x20\x03\x12\x03a\x18\x1a\n\x0b\n\x04\x04\0\
    \x02!\x12\x03b\x04\x16\n\x0c\n\x05\x04\0\x02!\x05\x12\x03b\x04\n\n\x0c\n\
    \x05\x04\0\x02!\x01\x12\x03b\x0b\x10\n\x0c\n\x05\x04\0\x02!\x03\x12\x03b\
    \x13\x15\n\x0b\n\x04\x04\0\x02\"\x12\x03c\x04\x1c\n\x0c\n\x05\x04\0\x02\
    \"\x05\x12\x03c\x04\n\n\x0c\n\x05\x04\0\x02\"\x01\x12\x03c\x0b\x16\n\x0c\
    \n\x05\x04\0\x02\"\x03\x12\x03c\x19\x1b\n\x0b\n\x04\x04\0\x02#\x12\x03d\
    \x04\x17\n\x0c\n\x05\x04\0\x02#\x05\x12\x03d\x04\n\n\x0c\n\x05\x04\0\x02\
    #\x01\x12\x03d\x0b\x11\n\x0c\n\x05\x04\0\x02#\x03\x12\x03d\x14\x16\n\x0b\
    \n\x04\x04\0\x02$\x12\x03e\x04\x1c\n\x0c\n\x05\x04\0\x02$\x05\x12\x03e\
    \x04\n\n\x0c\n\x05\x04\0\x02$\x01\x12\x03e\x0b\x16\n\x0c\n\x05\x04\0\x02\
    $\x03\x12\x03e\x19\x1b\n\x0b\n\x04\x04\0\x02%\x12\x03f\x04\x1a\n\x0c\n\
    \x05\x04\0\x02%\x05\x12\x03f\x04\t\n\x0c\n\x05\x04\0\x02%\x01\x12\x03f\n\
    \x14\n\x0c\n\x05\x04\0\x02%\x03\x12\x03f\x17\x19\n\x0b\n\x04\x04\0\x02&\
    \x12\x03g\x04\x17\n\x0c\n\x05\x04\0\x02&\x05\x12\x03g\x04\n\n\x0c\n\x05\
    \x04\0\x02&\x01\x12\x03g\x0b\x11\n\x0c\n\x05\x04\0\x02&\x03\x12\x03g\x14\
    \x16\n\x0b\n\x04\x04\0\x02'\x12\x03h\x04\x1b\n\x0c\n\x05\x04\0\x02'\x05\
    \x12\x03h\x04\n\n\x0c\n\x05\x04\0\x02'\x01\x12\x03h\x0b\x15\n\x0c\n\x05\
    \x04\0\x02'\x03\x12\x03h\x18\x1a\n\x0b\n\x04\x04\0\x02(\x12\x03i\x04\x1b\
    \n\x0c\n\x05\x04\0\x02(\x05\x12\x03i\x04\n\n\x0c\n\x05\x04\0\x02(\x01\
    \x12\x03i\x0b\x15\n\x0c\n\x05\x04\0\x02(\x03\x12\x03i\x18\x1a\n\x0b\n\
    \x04\x04\0\x02)\x12\x03j\x04\x1a\n\x0c\n\x05\x04\0\x02)\x05\x12\x03j\x04\
    \t\n\x0c\n\x05\x04\0\x02)\x01\x12\x03j\n\x14\n\x0c\n\x05\x04\0\x02)\x03\
    \x12\x03j\x17\x19\n\x0b\n\x04\x04\0\x02*\x12\x03k\x04\x1d\n\x0c\n\x05\
    \x04\0\x02*\x05\x12\x03k\x04\n\n\x0c\n\x05\x04\0\x02*\x01\x12\x03k\x0b\
    \x17\n\x0c\n\x05\x04\0\x02*\x03\x12\x03k\x1a\x1c\n\x0b\n\x04\x04\0\x02+\
    \x12\x03l\x04\x1f\n\x0c\n\x05\x04\0\x02+\x05\x12\x03l\x04\t\n\x0c\n\x05\
    \x04\0\x02+\x01\x12\x03l\n\x19\n\x0c\n\x05\x04\0\x02+\x03\x12\x03l\x1c\
    \x1e\n\x0b\n\x04\x04\0\x02,\x12\x03m\x04\x1b\n\x0c\n\x05\x04\0\x02,\x05\
    \x12\x03m\x04\n\n\x0c\n\x05\x04\0\x02,\x01\x12\x03m\x0b\x15\n\x0c\n\x05\
    \x04\0\x02,\x03\x12\x03m\x18\x1a\n\x0b\n\x04\x04\0\x02-\x12\x03n\x04\x1a\
    \n\x0c\n\x05\x04\0\x02-\x05\x12\x03n\x04\n\n\x0c\n\x05\x04\0\x02-\x01\
    \x12\x03n\x0b\x14\n\x0c\n\x05\x04\0\x02-\x03\x12\x03n\x17\x19\n\n\n\x02\
    \x04\x01\x12\x04q\0w\x01\n\n\n\x03\x04\x01\x01\x12\x03q\x08\x15\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03r\x04\x16\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03r\x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03r\x0b\x11\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03r\x14\x15\n\x0b\n\x04\x04\x01\x02\x01\x12\x03s\
    \x04\x15\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03s\x04\t\n\x0c\n\x05\x04\
    \x01\x02\x01\x01\x12\x03s\n\x10\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03s\
    \x13\x14\n\x0b\n\x04\x04\x01\x02\x02\x12\x03t\x04\x1b\n\x0c\n\x05\x04\
    \x01\x02\x02\x05\x12\x03t\x04\t\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03t\
    \n\x16\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03t\x19\x1a\n\x0b\n\x04\x04\
    \x01\x02\x03\x12\x03u\x04\x16\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03u\
    \x04\n\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03u\x0b\x11\n\x0c\n\x05\x04\
    \x01\x02\x03\x03\x12\x03u\x14\x15\n\x0b\n\x04\x04\x01\x02\x04\x12\x03v\
    \x04\x1b\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03v\x04\n\n\x0c\n\x05\x04\
    \x01\x02\x04\x01\x12\x03v\x0b\x16\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\
    \x03v\x19\x1a\n\n\n\x02\x04\x02\x12\x04y\0~\x01\n\n\n\x03\x04\x02\x01\
    \x12\x03y\x08\x13\n\x0b\n\x04\x04\x02\x02\0\x12\x03z\x04\x14\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03z\x04\t\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03z\
    \n\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03z\x12\x13\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x03{\x04\x17\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03{\
    \x04\t\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03{\n\x12\n\x0c\n\x05\x04\
    \x02\x02\x01\x03\x12\x03{\x15\x16\n\x0b\n\x04\x04\x02\x02\x02\x12\x03|\
    \x04\x13\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03|\x04\t\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x03|\n\x0e\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03|\
    \x11\x12\n\x0b\n\x04\x04\x02\x02\x03\x12\x03}\x04\x1e\n\x0c\n\x05\x04\
    \x02\x02\x03\x04\x12\x03}\x04\x0c\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\
    \x03}\r\x14\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03}\x15\x19\n\x0c\n\x05\
    \x04\x02\x02\x03\x03\x12\x03}\x1c\x1d\n\x0c\n\x02\x04\x03\x12\x06\x80\
    \x01\0\x85\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\x80\x01\x08\x1c\n\x0c\
    \n\x04\x04\x03\x02\0\x12\x04\x81\x01\x04\x17\n\r\n\x05\x04\x03\x02\0\x05\
    \x12\x04\x81\x01\x04\t\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x81\x01\n\x12\
    \n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x81\x01\x15\x16\n\x0c\n\x04\x04\x03\
    \x02\x01\x12\x04\x82\x01\x04\x15\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\
    \x82\x01\x04\t\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x82\x01\n\x10\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\x82\x01\x13\x14\n\x0c\n\x04\x04\x03\x02\
    \x02\x12\x04\x83\x01\x04\x12\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\x83\
    \x01\x04\t\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\x83\x01\n\r\n\r\n\x05\
    \x04\x03\x02\x02\x03\x12\x04\x83\x01\x10\x11\n\x0c\n\x04\x04\x03\x02\x03\
    \x12\x04\x84\x01\x04\x16\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\x84\x01\
    \x04\t\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\x84\x01\n\x11\n\r\n\x05\x04\
    \x03\x02\x03\x03\x12\x04\x84\x01\x14\x15\n\x0c\n\x02\x04\x04\x12\x06\x87\
    \x01\0\x8e\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x87\x01\x08\x16\n\x0c\
    \n\x04\x04\x04\x02\0\x12\x04\x88\x01\x04\x15\n\r\n\x05\x04\x04\x02\0\x05\
    \x12\x04\x88\x01\x04\t\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x88\x01\n\x10\
    \n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x88\x01\x13\x14\n\x0c\n\x04\x04\x04\
    \x02\x01\x12\x04\x89\x01\x04*\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\x89\
    \x01\x04\x18\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x89\x01\x19%\n\r\n\
    \x05\x04\x04\x02\x01\x03\x12\x04\x89\x01()\n\x0c\n\x04\x04\x04\x02\x02\
    \x12\x04\x8a\x01\x04%\n\r\n\x05\x04\x04\x02\x02\x06\x12\x04\x8a\x01\x04\
    \x18\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\x8a\x01\x19\x20\n\r\n\x05\x04\
    \x04\x02\x02\x03\x12\x04\x8a\x01#$\n\x0c\n\x04\x04\x04\x02\x03\x12\x04\
    \x8b\x01\x04'\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\x8b\x01\x04\x18\n\r\
    \n\x05\x04\x04\x02\x03\x01\x12\x04\x8b\x01\x19\"\n\r\n\x05\x04\x04\x02\
    \x03\x03\x12\x04\x8b\x01%&\n\x0c\n\x04\x04\x04\x02\x04\x12\x04\x8c\x01\
    \x04&\n\r\n\x05\x04\x04\x02\x04\x06\x12\x04\x8c\x01\x04\x18\n\r\n\x05\
    \x04\x04\x02\x04\x01\x12\x04\x8c\x01\x19!\n\r\n\x05\x04\x04\x02\x04\x03\
    \x12\x04\x8c\x01$%\n\x0c\n\x04\x04\x04\x02\x05\x12\x04\x8d\x01\x041\n\r\
    \n\x05\x04\x04\x02\x05\x04\x12\x04\x8d\x01\x04\x0c\n\r\n\x05\x04\x04\x02\
    \x05\x06\x12\x04\x8d\x01\r\"\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\x8d\
    \x01#,\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\x8d\x01/0\n\x0c\n\x02\x04\
    \x05\x12\x06\x90\x01\0\x96\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x90\
    \x01\x08\x1d\n\x0c\n\x04\x04\x05\x02\0\x12\x04\x91\x01\x04*\n\r\n\x05\
    \x04\x05\x02\0\x06\x12\x04\x91\x01\x04\x18\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\x91\x01\x19%\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x91\x01()\n\
    \x0c\n\x04\x04\x05\x02\x01\x12\x04\x92\x01\x04%\n\r\n\x05\x04\x05\x02\
    \x01\x06\x12\x04\x92\x01\x04\x18\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\
    \x92\x01\x19\x20\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x92\x01#$\n\x0c\n\
    \x04\x04\x05\x02\x02\x12\x04\x93\x01\x04'\n\r\n\x05\x04\x05\x02\x02\x06\
    \x12\x04\x93\x01\x04\x18\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\x93\x01\
    \x19\"\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x93\x01%&\n\x0c\n\x04\x04\
    \x05\x02\x03\x12\x04\x94\x01\x04&\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\
    \x94\x01\x04\x18\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\x94\x01\x19!\n\r\
    \n\x05\x04\x05\x02\x03\x03\x12\x04\x94\x01$%\n\x0c\n\x04\x04\x05\x02\x04\
    \x12\x04\x95\x01\x04\x16\n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\x95\x01\
    \x04\t\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\x95\x01\n\x11\n\r\n\x05\x04\
    \x05\x02\x04\x03\x12\x04\x95\x01\x14\x15\n\x0c\n\x02\x04\x06\x12\x06\x98\
    \x01\0\x9a\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x98\x01\x08\x16\n\x0c\
    \n\x04\x04\x06\x02\0\x12\x04\x99\x01\x04\x17\n\r\n\x05\x04\x06\x02\0\x05\
    \x12\x04\x99\x01\x04\n\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x99\x01\x0b\
    \x12\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x99\x01\x15\x16\n\x0c\n\x02\x04\
    \x07\x12\x06\x9c\x01\0\xa0\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x9c\
    \x01\x08\x17\n\x0c\n\x04\x04\x07\x02\0\x12\x04\x9d\x01\x04\x13\n\r\n\x05\
    \x04\x07\x02\0\x05\x12\x04\x9d\x01\x04\t\n\r\n\x05\x04\x07\x02\0\x01\x12\
    \x04\x9d\x01\n\x0e\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x9d\x01\x11\x12\n\
    \x0c\n\x04\x04\x07\x02\x01\x12\x04\x9e\x01\x04\x17\n\r\n\x05\x04\x07\x02\
    \x01\x05\x12\x04\x9e\x01\x04\n\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x9e\
    \x01\x0b\x12\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x9e\x01\x15\x16\n\x0c\
    \n\x04\x04\x07\x02\x02\x12\x04\x9f\x01\x04\x19\n\r\n\x05\x04\x07\x02\x02\
    \x06\x12\x04\x9f\x01\x04\x0b\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\x9f\
    \x01\x0c\x14\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\x9f\x01\x17\x18\n\x0c\
    \n\x02\x04\x08\x12\x06\xa2\x01\0\xa4\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xa2\x01\x08\x17\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xa3\x01\x04\x20\n\
    \r\n\x05\x04\x08\x02\0\x04\x12\x04\xa3\x01\x04\x0c\n\r\n\x05\x04\x08\x02\
    \0\x05\x12\x04\xa3\x01\r\x13\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xa3\x01\
    \x14\x1b\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xa3\x01\x1e\x1f\n\x0c\n\x02\
    \x04\t\x12\x06\xa6\x01\0\xaa\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xa6\
    \x01\x08\x18\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa7\x01\x04\x13\n\r\n\x05\
    \x04\t\x02\0\x05\x12\x04\xa7\x01\x04\t\n\r\n\x05\x04\t\x02\0\x01\x12\x04\
    \xa7\x01\n\x0e\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xa7\x01\x11\x12\n\x0c\n\
    \x04\x04\t\x02\x01\x12\x04\xa8\x01\x04\x17\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\xa8\x01\x04\n\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xa8\x01\x0b\
    \x12\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xa8\x01\x15\x16\n\x0c\n\x04\x04\
    \t\x02\x02\x12\x04\xa9\x01\x04\"\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xa9\
    \x01\x04\x0c\n\r\n\x05\x04\t\x02\x02\x06\x12\x04\xa9\x01\r\x14\n\r\n\x05\
    \x04\t\x02\x02\x01\x12\x04\xa9\x01\x15\x1d\n\r\n\x05\x04\t\x02\x02\x03\
    \x12\x04\xa9\x01\x20!\n\x0c\n\x02\x04\n\x12\x06\xac\x01\0\xb1\x01\x01\n\
    \x0b\n\x03\x04\n\x01\x12\x04\xac\x01\x08\"\n\x0c\n\x04\x04\n\x02\0\x12\
    \x04\xad\x01\x04\x1c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xad\x01\x04\n\n\r\
    \n\x05\x04\n\x02\0\x01\x12\x04\xad\x01\x0b\x17\n\r\n\x05\x04\n\x02\0\x03\
    \x12\x04\xad\x01\x1a\x1b\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xae\x01\x04\
    \x16\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xae\x01\x04\n\n\r\n\x05\x04\n\
    \x02\x01\x01\x12\x04\xae\x01\x0b\x11\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\
    \xae\x01\x14\x15\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xaf\x01\x04\x13\n\r\n\
    \x05\x04\n\x02\x02\x05\x12\x04\xaf\x01\x04\t\n\r\n\x05\x04\n\x02\x02\x01\
    \x12\x04\xaf\x01\n\x0e\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xaf\x01\x11\
    \x12\n\x0c\n\x04\x04\n\x02\x03\x12\x04\xb0\x01\x04\x17\n\r\n\x05\x04\n\
    \x02\x03\x05\x12\x04\xb0\x01\x04\n\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\
    \xb0\x01\x0b\x12\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xb0\x01\x15\x16\n\
    \x0c\n\x02\x04\x0b\x12\x06\xb3\x01\0\xb7\x01\x01\n\x0b\n\x03\x04\x0b\x01\
    \x12\x04\xb3\x01\x08#\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xb4\x01\x04\x13\
    \n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xb4\x01\x04\t\n\r\n\x05\x04\x0b\x02\
    \0\x01\x12\x04\xb4\x01\n\x0e\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xb4\x01\
    \x11\x12\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xb5\x01\x04\x17\n\r\n\x05\
    \x04\x0b\x02\x01\x05\x12\x04\xb5\x01\x04\n\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\xb5\x01\x0b\x12\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xb5\x01\
    \x15\x16\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xb6\x01\x04\x1d\n\r\n\x05\
    \x04\x0b\x02\x02\x06\x12\x04\xb6\x01\x04\x0f\n\r\n\x05\x04\x0b\x02\x02\
    \x01\x12\x04\xb6\x01\x10\x18\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xb6\
    \x01\x1b\x1c\n\x0c\n\x02\x04\x0c\x12\x06\xb9\x01\0\xc0\x01\x01\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\xb9\x01\x08\x1c\n\x0c\n\x04\x04\x0c\x02\0\x12\
    \x04\xba\x01\x04\x16\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xba\x01\x04\n\n\
    \r\n\x05\x04\x0c\x02\0\x01\x12\x04\xba\x01\x0b\x11\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\xba\x01\x14\x15\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xbb\
    \x01\x04\x13\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xbb\x01\x04\t\n\r\n\
    \x05\x04\x0c\x02\x01\x01\x12\x04\xbb\x01\n\x0e\n\r\n\x05\x04\x0c\x02\x01\
    \x03\x12\x04\xbb\x01\x11\x12\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xbc\x01\
    \x04\x14\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xbc\x01\x04\t\n\r\n\x05\
    \x04\x0c\x02\x02\x01\x12\x04\xbc\x01\n\x0f\n\r\n\x05\x04\x0c\x02\x02\x03\
    \x12\x04\xbc\x01\x12\x13\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\xbd\x01\x04\
    \x13\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xbd\x01\x04\t\n\r\n\x05\x04\
    \x0c\x02\x03\x01\x12\x04\xbd\x01\n\x0e\n\r\n\x05\x04\x0c\x02\x03\x03\x12\
    \x04\xbd\x01\x11\x12\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\xbe\x01\x04\x11\
    \n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\xbe\x01\x04\t\n\r\n\x05\x04\x0c\
    \x02\x04\x01\x12\x04\xbe\x01\n\x0c\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\
    \xbe\x01\x0f\x10\n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\xbf\x01\x04\x17\n\r\
    \n\x05\x04\x0c\x02\x05\x05\x12\x04\xbf\x01\x04\n\n\r\n\x05\x04\x0c\x02\
    \x05\x01\x12\x04\xbf\x01\x0b\x12\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\
    \xbf\x01\x15\x16\n\x0c\n\x02\x04\r\x12\x06\xc2\x01\0\xc6\x01\x01\n\x0b\n\
    \x03\x04\r\x01\x12\x04\xc2\x01\x08\x1d\n\x0c\n\x04\x04\r\x02\0\x12\x04\
    \xc3\x01\x04\x13\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xc3\x01\x04\t\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\xc3\x01\n\x0e\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\xc3\x01\x11\x12\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc4\x01\x04\x17\n\
    \r\n\x05\x04\r\x02\x01\x05\x12\x04\xc4\x01\x04\n\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\xc4\x01\x0b\x12\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc4\x01\
    \x15\x16\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xc5\x01\x04\x1d\n\r\n\x05\x04\
    \r\x02\x02\x06\x12\x04\xc5\x01\x04\x0f\n\r\n\x05\x04\r\x02\x02\x01\x12\
    \x04\xc5\x01\x10\x18\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xc5\x01\x1b\x1c\
    \n\x0c\n\x02\x04\x0e\x12\x06\xc8\x01\0\xcc\x01\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xc8\x01\x08!\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xc9\x01\x04\
    \x1c\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xc9\x01\x04\n\n\r\n\x05\x04\x0e\
    \x02\0\x01\x12\x04\xc9\x01\x0b\x17\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\
    \xc9\x01\x1a\x1b\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xca\x01\x04\x16\n\r\
    \n\x05\x04\x0e\x02\x01\x05\x12\x04\xca\x01\x04\n\n\r\n\x05\x04\x0e\x02\
    \x01\x01\x12\x04\xca\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xca\x01\x14\x15\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xcb\x01\x04\x17\n\r\
    \n\x05\x04\x0e\x02\x02\x05\x12\x04\xcb\x01\x04\n\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\xcb\x01\x0b\x12\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\
    \xcb\x01\x15\x16\n\x0c\n\x02\x04\x0f\x12\x06\xce\x01\0\xd2\x01\x01\n\x0b\
    \n\x03\x04\x0f\x01\x12\x04\xce\x01\x08\"\n\x0c\n\x04\x04\x0f\x02\0\x12\
    \x04\xcf\x01\x04\x13\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xcf\x01\x04\t\n\
    \r\n\x05\x04\x0f\x02\0\x01\x12\x04\xcf\x01\n\x0e\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xcf\x01\x11\x12\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xd0\x01\
    \x04\x17\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xd0\x01\x04\n\n\r\n\x05\
    \x04\x0f\x02\x01\x01\x12\x04\xd0\x01\x0b\x12\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\xd0\x01\x15\x16\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xd1\x01\
    \x04\x19\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xd1\x01\x04\x0b\n\r\n\x05\
    \x04\x0f\x02\x02\x01\x12\x04\xd1\x01\x0c\x14\n\r\n\x05\x04\x0f\x02\x02\
    \x03\x12\x04\xd1\x01\x17\x18\n\x0c\n\x02\x04\x10\x12\x06\xd4\x01\0\xde\
    \x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xd4\x01\x08\x1c\n\x0c\n\x04\x04\
    \x10\x02\0\x12\x04\xd5\x01\x04\x17\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\
    \xd5\x01\x04\n\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xd5\x01\x0b\x12\n\r\n\
    \x05\x04\x10\x02\0\x03\x12\x04\xd5\x01\x15\x16\n\x0c\n\x04\x04\x10\x02\
    \x01\x12\x04\xd6\x01\x04\x1c\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xd6\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xd6\x01\x0b\x17\n\r\n\
    \x05\x04\x10\x02\x01\x03\x12\x04\xd6\x01\x1a\x1b\n\x0c\n\x04\x04\x10\x02\
    \x02\x12\x04\xd7\x01\x04\x16\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xd7\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xd7\x01\x0b\x11\n\r\n\
    \x05\x04\x10\x02\x02\x03\x12\x04\xd7\x01\x14\x15\n\x0c\n\x04\x04\x10\x02\
    \x03\x12\x04\xd8\x01\x04\x18\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xd8\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xd8\x01\x0b\x13\n\r\n\
    \x05\x04\x10\x02\x03\x03\x12\x04\xd8\x01\x16\x17\n\x0c\n\x04\x04\x10\x02\
    \x04\x12\x04\xd9\x01\x04\x18\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xd9\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xd9\x01\x0b\x13\n\r\n\
    \x05\x04\x10\x02\x04\x03\x12\x04\xd9\x01\x16\x17\n\x0c\n\x04\x04\x10\x02\
    \x05\x12\x04\xda\x01\x04\x16\n\r\n\x05\x04\x10\x02\x05\x05\x12\x04\xda\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xda\x01\x0b\x11\n\r\n\
    \x05\x04\x10\x02\x05\x03\x12\x04\xda\x01\x14\x15\n\x0c\n\x04\x04\x10\x02\
    \x06\x12\x04\xdb\x01\x04\x1d\n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\xdb\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xdb\x01\x0b\x18\n\r\n\
    \x05\x04\x10\x02\x06\x03\x12\x04\xdb\x01\x1b\x1c\n\x0c\n\x04\x04\x10\x02\
    \x07\x12\x04\xdc\x01\x04\x1b\n\r\n\x05\x04\x10\x02\x07\x05\x12\x04\xdc\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x07\x01\x12\x04\xdc\x01\x0b\x16\n\r\n\
    \x05\x04\x10\x02\x07\x03\x12\x04\xdc\x01\x19\x1a\n\x0c\n\x04\x04\x10\x02\
    \x08\x12\x04\xdd\x01\x04\x1e\n\r\n\x05\x04\x10\x02\x08\x05\x12\x04\xdd\
    \x01\x04\n\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\xdd\x01\x0b\x19\n\r\n\
    \x05\x04\x10\x02\x08\x03\x12\x04\xdd\x01\x1c\x1d\n\x0c\n\x02\x04\x11\x12\
    \x06\xe0\x01\0\xe4\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xe0\x01\x08\
    \x1d\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xe1\x01\x04\x13\n\r\n\x05\x04\x11\
    \x02\0\x05\x12\x04\xe1\x01\x04\t\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xe1\
    \x01\n\x0e\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xe1\x01\x11\x12\n\x0c\n\
    \x04\x04\x11\x02\x01\x12\x04\xe2\x01\x04\x17\n\r\n\x05\x04\x11\x02\x01\
    \x05\x12\x04\xe2\x01\x04\n\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe2\x01\
    \x0b\x12\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xe2\x01\x15\x16\n\x0c\n\
    \x04\x04\x11\x02\x02\x12\x04\xe3\x01\x04\x19\n\r\n\x05\x04\x11\x02\x02\
    \x06\x12\x04\xe3\x01\x04\x0b\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xe3\
    \x01\x0c\x14\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xe3\x01\x17\x18\n\x0c\
    \n\x02\x04\x12\x12\x06\xe6\x01\0\xe8\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xe6\x01\x08\x1d\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xe7\x01\x04\x17\n\
    \r\n\x05\x04\x12\x02\0\x05\x12\x04\xe7\x01\x04\n\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\xe7\x01\x0b\x12\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xe7\x01\
    \x15\x16\n\x0c\n\x02\x04\x13\x12\x06\xea\x01\0\xee\x01\x01\n\x0b\n\x03\
    \x04\x13\x01\x12\x04\xea\x01\x08\x1e\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \xeb\x01\x04\x13\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xeb\x01\x04\t\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xeb\x01\n\x0e\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xeb\x01\x11\x12\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xec\x01\x04\
    \x17\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xec\x01\x04\n\n\r\n\x05\x04\
    \x13\x02\x01\x01\x12\x04\xec\x01\x0b\x12\n\r\n\x05\x04\x13\x02\x01\x03\
    \x12\x04\xec\x01\x15\x16\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xed\x01\x04\
    \x20\n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\xed\x01\x04\x12\n\r\n\x05\x04\
    \x13\x02\x02\x01\x12\x04\xed\x01\x13\x1b\n\r\n\x05\x04\x13\x02\x02\x03\
    \x12\x04\xed\x01\x1e\x1f\n\x0c\n\x02\x04\x14\x12\x06\xf0\x01\0\xf3\x01\
    \x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xf0\x01\x08\x0f\n\x0c\n\x04\x04\x14\
    \x02\0\x12\x04\xf1\x01\x04\x1c\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xf1\
    \x01\x04\n\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xf1\x01\x0b\x17\n\r\n\x05\
    \x04\x14\x02\0\x03\x12\x04\xf1\x01\x1a\x1b\n\x0c\n\x04\x04\x14\x02\x01\
    \x12\x04\xf2\x01\x04\x15\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xf2\x01\
    \x04\t\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xf2\x01\n\x10\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xf2\x01\x13\x14\n\x0c\n\x02\x04\x15\x12\x06\xf5\
    \x01\0\xf8\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xf5\x01\x08\x1d\n\x0c\
    \n\x04\x04\x15\x02\0\x12\x04\xf6\x01\x04\x1c\n\r\n\x05\x04\x15\x02\0\x05\
    \x12\x04\xf6\x01\x04\n\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xf6\x01\x0b\
    \x17\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xf6\x01\x1a\x1b\n\x0c\n\x04\x04\
    \x15\x02\x01\x12\x04\xf7\x01\x04\x16\n\r\n\x05\x04\x15\x02\x01\x05\x12\
    \x04\xf7\x01\x04\n\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xf7\x01\x0b\x11\
    \n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xf7\x01\x14\x15\n\x0c\n\x02\x04\
    \x16\x12\x06\xfa\x01\0\xfe\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xfa\
    \x01\x08\x1e\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xfb\x01\x04\x13\n\r\n\x05\
    \x04\x16\x02\0\x05\x12\x04\xfb\x01\x04\t\n\r\n\x05\x04\x16\x02\0\x01\x12\
    \x04\xfb\x01\n\x0e\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xfb\x01\x11\x12\n\
    \x0c\n\x04\x04\x16\x02\x01\x12\x04\xfc\x01\x04\x17\n\r\n\x05\x04\x16\x02\
    \x01\x05\x12\x04\xfc\x01\x04\n\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xfc\
    \x01\x0b\x12\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xfc\x01\x15\x16\n\x0c\
    \n\x04\x04\x16\x02\x02\x12\x04\xfd\x01\x04\x19\n\r\n\x05\x04\x16\x02\x02\
    \x06\x12\x04\xfd\x01\x04\x0b\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xfd\
    \x01\x0c\x14\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xfd\x01\x17\x18\n\x0c\
    \n\x02\x04\x17\x12\x06\x80\x02\0\x82\x02\x01\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\x80\x02\x08\x20\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x81\x02\x04\x1c\n\
    \r\n\x05\x04\x17\x02\0\x05\x12\x04\x81\x02\x04\n\n\r\n\x05\x04\x17\x02\0\
    \x01\x12\x04\x81\x02\x0b\x17\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x81\x02\
    \x1a\x1bb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        deps.push(super::annotations::file_descriptor());
        let mut messages = ::std::vec::Vec::new();
        messages.push(Payment::generated_message_descriptor_data());
        messages.push(CancelHistory::generated_message_descriptor_data());
        messages.push(PaymentPage::generated_message_descriptor_data());
        messages.push(PaymentBalanceDetail::generated_message_descriptor_data());
        messages.push(PaymentBalance::generated_message_descriptor_data());
        messages.push(PaymentBalanceHistory::generated_message_descriptor_data());
        messages.push(PaymentRequest::generated_message_descriptor_data());
        messages.push(PaymentResponse::generated_message_descriptor_data());
        messages.push(PaymentsRequest::generated_message_descriptor_data());
        messages.push(PaymentsResponse::generated_message_descriptor_data());
        messages.push(PaymentsMerchantUidRequest::generated_message_descriptor_data());
        messages.push(PaymentsMerchantUidResponse::generated_message_descriptor_data());
        messages.push(PaymentStatusRequest::generated_message_descriptor_data());
        messages.push(PaymentStatusResponse::generated_message_descriptor_data());
        messages.push(PaymentMerchantUidRequest::generated_message_descriptor_data());
        messages.push(PaymentMerchantUidResponse::generated_message_descriptor_data());
        messages.push(PaymentCancelRequest::generated_message_descriptor_data());
        messages.push(PaymentCancelResponse::generated_message_descriptor_data());
        messages.push(PaymentBalanceRequest::generated_message_descriptor_data());
        messages.push(PaymentBalanceResponse::generated_message_descriptor_data());
        messages.push(Prepare::generated_message_descriptor_data());
        messages.push(PaymentPrepareRequest::generated_message_descriptor_data());
        messages.push(PaymentPrepareResponse::generated_message_descriptor_data());
        messages.push(PaymentGetPrepareRequest::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
